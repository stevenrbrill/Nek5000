c- constants -----------------------------------------------------------
#include "experimental/rans_komg.f"

#define tSTATSTART uparam(1) /* start time for averaging */
#define tSTATFREQ  uparam(2) /* output frequency for statistics */

c data extraction along wall normal direction
#define INTP_NMAX 2000 /* number of sample points */
#define XCINT 0.1     /* x coordinate of 1D line*/
#define ZCINT 0.0     /* z coordinate of 1D line */

c mesh dimensions
#define BETAM 2.4     /* wall normal stretching parameter */
#define PI (4.*atan(1.))
#define XLEN 0.5
#define ZLEN 0
#define NUMBER_ELEMENTS_X 3
#define NUMBER_ELEMENTS_Y 8
#define NUMBER_ELEMENTS_Z 1

c-----------------------------------------------------------------------
      subroutine abssub2(a,b,n)
      REAL A(1),B(1)
C
      include 'OPCTR'
C
      DO 100 I=1,N
         A(I)=A(I)-abs(B(I))
 100  CONTINUE
      return
      end
c-----------------------------------------------------------------------
      subroutine projenrich ()
      ! Removes enrichment components from polynomial solution
      include 'SIZE'
      include 'SOLN'

      common /enrich/ wsx(lx1,ly1,lz1,lelv)
     $               ,wsy(lx1,ly1,lz1,lelv)
     $               ,wsz(lx1,ly1,lz1,lelv)
     $               ,vx_(lx1,ly1,lz1,lelv)
     $               ,term3x(lx1,ly1,lz1,lelv)
     $               ,convx(lx1,ly1,lz1,lelv)
     $               ,wintx(lx1,ly1,lz1,lelv)
     $               ,winty(lx1,ly1,lz1,lelv)
     $               ,wintz(lx1,ly1,lz1,lelv)
     $               ,wrhsx(lx1,ly1,lz1,lelv)
     $               ,wrhsy(lx1,ly1,lz1,lelv)
     $               ,wrhsz(lx1,ly1,lz1,lelv)
     $               ,psix(lx1,ly1,lz1,lelv)
     $               ,psiy(lx1,ly1,lz1,lelv)
     $               ,psiz(lx1,ly1,lz1,lelv)
     $               ,gpsix_x(lx1,ly1,lz1,lelv)
     $               ,gpsix_y(lx1,ly1,lz1,lelv)
     $               ,gpsix_z(lx1,ly1,lz1,lelv)
     $               ,gpsiy_x(lx1,ly1,lz1,lelv)
     $               ,gpsiy_y(lx1,ly1,lz1,lelv)
     $               ,gpsiy_z(lx1,ly1,lz1,lelv)
     $               ,gpsiz_x(lx1,ly1,lz1,lelv)
     $               ,gpsiz_y(lx1,ly1,lz1,lelv)
     $               ,gpsiz_z(lx1,ly1,lz1,lelv)
     $               ,psix_rhs(lx1,ly1,lz1,lelv)
     $               ,psiy_rhs(lx1,ly1,lz1,lelv)
     $               ,psiz_rhs(lx1,ly1,lz1,lelv)
     
      NTOT1=lx1*ly1*lz1*NELV
      CALL SUB2(vx,psix,NTOT1)
      CALL SUB2(vy,psiy,NTOT1)
      CALL SUB2(vz,psiz,NTOT1)

      return
      end

c-----------------------------------------------------------------------
      subroutine unprojenrich ()
      ! Adds enrichment components to the polynomial solution
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      common /enrich/ wsx(lx1,ly1,lz1,lelv)
     $               ,wsy(lx1,ly1,lz1,lelv)
     $               ,wsz(lx1,ly1,lz1,lelv)
     $               ,vx_(lx1,ly1,lz1,lelv)
     $               ,term3x(lx1,ly1,lz1,lelv)
     $               ,convx(lx1,ly1,lz1,lelv)
     $               ,wintx(lx1,ly1,lz1,lelv)
     $               ,winty(lx1,ly1,lz1,lelv)
     $               ,wintz(lx1,ly1,lz1,lelv)
     $               ,wrhsx(lx1,ly1,lz1,lelv)
     $               ,wrhsy(lx1,ly1,lz1,lelv)
     $               ,wrhsz(lx1,ly1,lz1,lelv)
     $               ,psix(lx1,ly1,lz1,lelv)
     $               ,psiy(lx1,ly1,lz1,lelv)
     $               ,psiz(lx1,ly1,lz1,lelv)
     $               ,gpsix_x(lx1,ly1,lz1,lelv)
     $               ,gpsix_y(lx1,ly1,lz1,lelv)
     $               ,gpsix_z(lx1,ly1,lz1,lelv)
     $               ,gpsiy_x(lx1,ly1,lz1,lelv)
     $               ,gpsiy_y(lx1,ly1,lz1,lelv)
     $               ,gpsiy_z(lx1,ly1,lz1,lelv)
     $               ,gpsiz_x(lx1,ly1,lz1,lelv)
     $               ,gpsiz_y(lx1,ly1,lz1,lelv)
     $               ,gpsiz_z(lx1,ly1,lz1,lelv)
     $               ,psix_rhs(lx1,ly1,lz1,lelv)
     $               ,psiy_rhs(lx1,ly1,lz1,lelv)
     $               ,psiz_rhs(lx1,ly1,lz1,lelv)
      NTOT1=lx1*ly1*lz1*NELV
      CALL ADD2(vx,psix,NTOT1)
      CALL ADD2(vy,psiy,NTOT1)
      CALL ADD2(vz,psiz,NTOT1)

      return
      end


c-----------------------------------------------------------------------
      subroutine srbprint (u)
      ! Print the solution 
      include 'SIZE'
      include 'TOTAL'

      real u(lx1, ly1, lz1, nelv)

      do iel = 1, nelv
        do ix = 1,lx1
          do iy = 1,ly1
            do iz = 1,lz1
                  print *, iel, ix, iy, iz, u(ix,iy,iz,iel)
            enddo
          enddo
        enddo
      enddo

      return
      end

c-----------------------------------------------------------------------
      subroutine userhack (ix,iy,iz,ieg)
      ! Access to the RHS hacks for continuity enforcement
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e

      common /enrich/ wsx(lx1,ly1,lz1,lelv)
     $               ,wsy(lx1,ly1,lz1,lelv)
     $               ,wsz(lx1,ly1,lz1,lelv)
     $               ,vx_(lx1,ly1,lz1,lelv)
     $               ,term3x(lx1,ly1,lz1,lelv)
     $               ,convx(lx1,ly1,lz1,lelv)
     $               ,wintx(lx1,ly1,lz1,lelv)
     $               ,winty(lx1,ly1,lz1,lelv)
     $               ,wintz(lx1,ly1,lz1,lelv)
     $               ,wrhsx(lx1,ly1,lz1,lelv)
     $               ,wrhsy(lx1,ly1,lz1,lelv)
     $               ,wrhsz(lx1,ly1,lz1,lelv)
     $               ,psix(lx1,ly1,lz1,lelv)
     $               ,psiy(lx1,ly1,lz1,lelv)
     $               ,psiz(lx1,ly1,lz1,lelv)
     $               ,gpsix_x(lx1,ly1,lz1,lelv)
     $               ,gpsix_y(lx1,ly1,lz1,lelv)
     $               ,gpsix_z(lx1,ly1,lz1,lelv)
     $               ,gpsiy_x(lx1,ly1,lz1,lelv)
     $               ,gpsiy_y(lx1,ly1,lz1,lelv)
     $               ,gpsiy_z(lx1,ly1,lz1,lelv)
     $               ,gpsiz_x(lx1,ly1,lz1,lelv)
     $               ,gpsiz_y(lx1,ly1,lz1,lelv)
     $               ,gpsiz_z(lx1,ly1,lz1,lelv)
     $               ,psix_rhs(lx1,ly1,lz1,lelv)
     $               ,psiy_rhs(lx1,ly1,lz1,lelv)
     $               ,psiz_rhs(lx1,ly1,lz1,lelv)

      e = gllel(ieg)

      rhsx = wrhsx(ix,iy,iz,e) 
      rhsy = wrhsy(ix,iy,iz,e)
      rhsz = wrhsz(ix,iy,iz,e)

      return
      end

c-----------------------------------------------------------------------
      subroutine userfint (ix,iy,iz,ieg)
      ! Access to the pre-integrated quantities
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e

      common /enrich/ wsx(lx1,ly1,lz1,lelv)
     $               ,wsy(lx1,ly1,lz1,lelv)
     $               ,wsz(lx1,ly1,lz1,lelv)
     $               ,vx_(lx1,ly1,lz1,lelv)
     $               ,term3x(lx1,ly1,lz1,lelv)
     $               ,convx(lx1,ly1,lz1,lelv)
     $               ,wintx(lx1,ly1,lz1,lelv)
     $               ,winty(lx1,ly1,lz1,lelv)
     $               ,wintz(lx1,ly1,lz1,lelv)
     $               ,wrhsx(lx1,ly1,lz1,lelv)
     $               ,wrhsy(lx1,ly1,lz1,lelv)
     $               ,wrhsz(lx1,ly1,lz1,lelv)
     $               ,psix(lx1,ly1,lz1,lelv)
     $               ,psiy(lx1,ly1,lz1,lelv)
     $               ,psiz(lx1,ly1,lz1,lelv)
     $               ,gpsix_x(lx1,ly1,lz1,lelv)
     $               ,gpsix_y(lx1,ly1,lz1,lelv)
     $               ,gpsix_z(lx1,ly1,lz1,lelv)
     $               ,gpsiy_x(lx1,ly1,lz1,lelv)
     $               ,gpsiy_y(lx1,ly1,lz1,lelv)
     $               ,gpsiy_z(lx1,ly1,lz1,lelv)
     $               ,gpsiz_x(lx1,ly1,lz1,lelv)
     $               ,gpsiz_y(lx1,ly1,lz1,lelv)
     $               ,gpsiz_z(lx1,ly1,lz1,lelv)
     $               ,psix_rhs(lx1,ly1,lz1,lelv)
     $               ,psiy_rhs(lx1,ly1,lz1,lelv)
     $               ,psiz_rhs(lx1,ly1,lz1,lelv)

      e = gllel(ieg)

      ffintx = wintx(ix,iy,iz,e) 
      ffinty = winty(ix,iy,iz,e)
      ffintz = wintz(ix,iy,iz,e)

      return
      end

c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,eg)
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer ix,iy,iz,e,eg
      real rans_komg_mut,rans_komg_mutsk,rans_komg_mutso
      real mu_t,Pr_t

      e = gllel(eg)

      Pr_t=0.91
      mu_t=rans_komg_mut(ix,iy,iz,e)

      utrans = cpfld(ifield,2)
      if(ifield.eq.1) then
        udiff = cpfld(ifield,1)+mu_t
      elseif(ifield.eq.2) then
        udiff = cpfld(ifield,1)+mu_t*cpfld(ifield,2)/(Pr_t*cpfld(1,2))
      elseif(ifield.eq.3) then
        udiff = cpfld(ifield,1)+rans_komg_mutsk(ix,iy,iz,e)
      elseif(ifield.eq.4) then
        udiff = cpfld(ifield,1)+rans_komg_mutso(ix,iy,iz,e)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      ! Access to the forcing functions
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

c     Effective enrichment source terms for momentum equation
      common /enrich/ wsx(lx1,ly1,lz1,lelv)
     $               ,wsy(lx1,ly1,lz1,lelv)
     $               ,wsz(lx1,ly1,lz1,lelv)
     $               ,vx_(lx1,ly1,lz1,lelv)
     $               ,term3x(lx1,ly1,lz1,lelv)
     $               ,convx(lx1,ly1,lz1,lelv)
     $               ,wintx(lx1,ly1,lz1,lelv)
     $               ,winty(lx1,ly1,lz1,lelv)
     $               ,wintz(lx1,ly1,lz1,lelv)
     $               ,wrhsx(lx1,ly1,lz1,lelv)
     $               ,wrhsy(lx1,ly1,lz1,lelv)
     $               ,wrhsz(lx1,ly1,lz1,lelv)
     $               ,psix(lx1,ly1,lz1,lelv)
     $               ,psiy(lx1,ly1,lz1,lelv)
     $               ,psiz(lx1,ly1,lz1,lelv)
     $               ,gpsix_x(lx1,ly1,lz1,lelv)
     $               ,gpsix_y(lx1,ly1,lz1,lelv)
     $               ,gpsix_z(lx1,ly1,lz1,lelv)
     $               ,gpsiy_x(lx1,ly1,lz1,lelv)
     $               ,gpsiy_y(lx1,ly1,lz1,lelv)
     $               ,gpsiy_z(lx1,ly1,lz1,lelv)
     $               ,gpsiz_x(lx1,ly1,lz1,lelv)
     $               ,gpsiz_y(lx1,ly1,lz1,lelv)
     $               ,gpsiz_z(lx1,ly1,lz1,lelv)
     $               ,psix_rhs(lx1,ly1,lz1,lelv)
     $               ,psiy_rhs(lx1,ly1,lz1,lelv)
     $               ,psiz_rhs(lx1,ly1,lz1,lelv)

      e = gllel(ieg)

      ffx = wsx(ix,iy,iz,e) 
      ffy = wsy(ix,iy,iz,e)
      ffz = wsz(ix,iy,iz,e)

      return
      end
c-----------------------------------------------------------------------
      subroutine userq(ix,iy,iz,eg) ! set source term
C       implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer ix,iy,iz,e,eg
      real srb_rans_komg_kSrc,srb_rans_komg_omgSrc

      common /ransenrich/ wsk(lx1,ly1,lz1,lelv)
     $                  , wsomg(lx1,ly1,lz1,lelv)


      e = gllel(eg)

      if(ifield.eq.3) then
        qvol = srb_rans_komg_kSrc(ix,iy,iz,e) + wsk(ix,iy,iz,e)
      elseif(ifield.eq.4) then
        qvol = srb_rans_komg_omgSrc(ix,iy,iz,e) + wsomg(ix,iy,iz,e)
      else
        qvol = 0.0
      endif

      return
      end

c-----------------------------------------------------------------------
      real function lotw (yw,utau,nu)
      ! Evaluate law of the wall
      implicit none
      real x, y, z, utau, nu ! Wall distance
      integer flag
      real Re_tau, ypb, yw, yp
      
      ypb = 11.062299784340414
      yp = yw*utau/nu

      ! Piecewise law of the wall
C       if (yp .gt. ypb) then
C          lotw = utau*(1.0/0.41*log(yp)+5.2)
C       elseif (yp .le. ypb) then
C          lotw = utau*yp
C       endif

      ! Reichardt law of the wall
      lotw = utau*((1./0.41)*log(1.+0.41*yp)+7.8*
     $      (1.-exp(-yp/(11.))-yp/(11.)*exp(-yp/(3.)))) ! Reichardt

      return
      end

c-----------------------------------------------------------------------
      real function dlotwdy (yw,utau,nu)
      ! Evaluate gradient of of law of the wall
      implicit none
      real x, y, z, utau, nu 
      integer flag
      real Re_tau, ypb, yw, yp
      integer sign

      ypb = 11.062299784340414
      Re_tau = utau/nu
      yp = yw*utau/nu

      ! Piecewise law of the wall
C       if (yp .gt. ypb) then
C         dlotwdy = Re_tau*utau*(1.0/(0.41*yp))
C       elseif (yp .le. ypb) then
C         dlotwdy = Re_tau*utau
C       endif

      ! Reichardt law of the wall
      dlotwdy = Re_tau*utau*(1./(1.+0.41*yp)+7.8*
     $      (1./11.*exp(-yp/(11.))+(yp-3.)/(33.)*exp(-yp/(3.)))) ! Reichardt

      return
      end

c-----------------------------------------------------------------------
      real function calc_psi  (x,y,z,flag,utau,nu)
      ! Evaluate enrichment function
      implicit none
      real x, y, z, utau, nu ! Wall distance
      integer flag
      real Re_tau, ypb, yw
      real lotw
      
      Re_tau = utau/nu

      ! Distance from wall
      if (flag .gt. 0) then
        yw = (1-y)
      elseif (flag .lt. 0) then
        yw = (1+y) 
      endif

      ! Enrichment value
      calc_psi = lotw(yw,utau,nu)

      return
      end

c-----------------------------------------------------------------------
      real function calc_gpsix_y  (x,y,z,flag,utau,nu)
      ! Evaluate enrichment gradient
      implicit none
      real x, y, z, utau, nu 
      integer flag
      real Re_tau, ypb, yw
      integer sign
      real dlotwdy

      ypb = 11.062299784340414
      Re_tau = utau/nu

      ! Distance from wall
      if (flag .gt. 0) then
        yw = (1-y)
        sign = -1
      elseif (flag .lt. 0) then
        yw = (1+y)
        sign = 1
      endif

      ! Enrichment gradient
      calc_gpsix_y = sign*dlotwdy(yw,utau,nu)

      return
      end

c-----------------------------------------------------------------------
      subroutine userchk ()
      include 'SIZE'
      include 'TOTAL'
      include 'RANS_KOMG'

      integer ILAG

      real x0(3)
      data x0 /0.0, 0.0, 0.0/ 
      save x0

      integer icalld
      save    icalld
      data    icalld /0/

      real atime,timel
      save atime,timel

      integer ntdump
      save    ntdump

      real    rwk(INTP_NMAX,ldim+1) ! r, s, t, dist2
      integer iwk(INTP_NMAX,3)      ! code, proc, el 
      save    rwk, iwk

      integer nint, intp_h
      save    nint, intp_h

      logical iffpts
      save iffpts

      real xint(INTP_NMAX),yint(INTP_NMAX),zint(INTP_NMAX)
      save xint, yint, zint
      save igs_x, igs_z

      parameter(nstat=13)
      real ravg(lx1*ly1*lz1*lelt,nstat)
      real stat(lx1*ly1*lz1*lelt,nstat)
      real stat_y(INTP_NMAX*nstat)
      save ravg, stat, stat_y

      save dragx_avg, dragx_avg_poly
      real tw_poly, u_tau_poly

      logical ifverbose
      common /gaaa/    wo1(lx1,ly1,lz1,lelv)
     &              ,  wo2(lx1,ly1,lz1,lelv)
     &              ,  wo3(lx1,ly1,lz1,lelv)

      integer flag(lelv)
      common /beflag/ flag

c----------------------------------------------------------------
c     VARIABLES DECLARED FOR USING THE NON-ITERATIVE METHOD  
      real tauold(lx1,ly1,lz1,lelv), taunew(lx1,ly1,lz1,lelv)
      common /wallshear/ taunew
      save tauold
      
      real M, Kappa, utau_init
      data M/5.17/, kappa/0.41/, utau_init/0.2/
      save M, kappa, utau_init
c----------------------------------------------------------------
c     VARIABLES DECLARED FOR USING THE ITERATIVE METHOD 
      real newton,secant,rtol,ut0,ut1,uti(lx1,ly1,lz1,lelv),utau
      integer flg, maxiter, count
      data rtol/1.0e-5/, maxiter/20000/
      data flg/2/, count/0/ !flg = flag for the chosen wall model
c      data uti/0.2/  !Initial guess value of utau for Newton Method
      data ut0/0.04/, ut1/0.08/ !Initial guess values for Secant Method
      save rtol, maxiter, flg, uti, ut0, ut1
c---------------------------------------------------------------

      real tplus
      real tmn, tmx   

      integer bIDs(1)
      save iobj_wall

c---------------------------------------------------------------
c     VARIABLES DECLARED FOR ENRICHMENT METHOD
      integer secondcall
      save secondcall
      real utau_ref, Re_tau
C       real psix(lx1,ly1,lz1,lelv)
C       real gpsix_x(lx1,ly1,lz1,lelv), gpsix_y(lx1,ly1,lz1,lelv)
C       real gpsix_z(lx1,ly1,lz1,lelv), gpsiy_x(lx1,ly1,lz1,lelv)
C       real gpsiy_y(lx1,ly1,lz1,lelv), gpsiy_z(lx1,ly1,lz1,lelv)
C       real gpsiz_x(lx1,ly1,lz1,lelv), gpsiz_y(lx1,ly1,lz1,lelv)
C       real gpsiz_z(lx1,ly1,lz1,lelv)
C       real psiy(lx1,ly1,lz1,lelv), psiz(lx1,ly1,lz1,lelv) 
      real myH1(lx1,ly1,lz1,lelv), myH2(lx1,ly1,lz1,lelv) 
      real myH1_rhs(lx1,ly1,lz1,lelv), myH2_rhs(lx1,ly1,lz1,lelv) 
      real phi_temp(lx1,ly1,lz1,lelv), T1_rhs_x(lx1,ly1,lz1,lelv) 
      real T1_rhs_y(lx1,ly1,lz1,lelv), T1_rhs_z(lx1,ly1,lz1,lelv) 
      save T1_rhs_x, T1_rhs_y, T1_rhs_z
      save T1_rhs
      integer comp_T1, comp_en_F, comp_psi, iy_ut, avg_ind, use_default
      save comp_T1, comp_en_F, comp_psi
      real tau_w(lx1,ly1,lz1,lelv)
      real srb_temp(lx1,ly1,lz1,lelv)
      integer ib, ib2, iz_end
      real srbtest, ut_param, tau_param
      real psix_int(INTP_NMAX)
      save psix_int
      integer comp_phi_grad
      save comp_phi_grad
      integer nb
      common /phigrad/ dpdr(lx1*ly1*lz1,lx1*ly1*lz1)
     $                ,dpds(lx1*ly1*lz1,lx1*ly1*lz1)
     $                ,dpdt(lx1*ly1*lz1,lx1*ly1*lz1)
     $                ,dpdx(lx1*ly1*lz1,lx1*ly1*lz1,lelv)
     $                ,dpdy(lx1*ly1*lz1,lx1*ly1*lz1,lelv)
     $                ,dpdz(lx1*ly1*lz1,lx1*ly1*lz1,lelv)
                               !(nb,nq)
      data utau_ref/5.43496e-02/  !Assumed constant value of u_tau
      common /y_ends/ bot_y, top_y
      real w1(lx1,ly1,lz1,lelv)
     $              ,w2(lx1,ly1,lz1,lelv)
     $              ,w3(lx1,ly1,lz1,lelv)
     $              ,tx(lx1,ly1,lz1,lelv)
     $              ,ty(lx1,ly1,lz1,lelv)
     $              ,tz(lx1,ly1,lz1,lelv)
      real txx(lx1,ly1,lz1,lelv)
     $               ,tyy(lx1,ly1,lz1,lelv)
     $               ,tzz(lx1,ly1,lz1,lelv)
     $               ,txy(lx1,ly1,lz1,lelv)
     $               ,tyz(lx1,ly1,lz1,lelv)
     $               ,txz(lx1,ly1,lz1,lelv)
     $               ,tr1x(lx1,ly1,lz1,lelv)
     $               ,tr1y(lx1,ly1,lz1,lelv)
     $               ,tr1z(lx1,ly1,lz1,lelv)
     $               ,tr2x(lx1,ly1,lz1,lelv)
     $               ,tr2y(lx1,ly1,lz1,lelv)
     $               ,tr2z(lx1,ly1,lz1,lelv)
     $               ,tr3x(lx1,ly1,lz1,lelv)
     $               ,tr3y(lx1,ly1,lz1,lelv)
     $               ,tr3z(lx1,ly1,lz1,lelv)
     $               ,tr4x(lx1,ly1,lz1,lelv)
     $               ,tr4y(lx1,ly1,lz1,lelv)
     $               ,tr4z(lx1,ly1,lz1,lelv)
      common /enrich/ wsx(lx1,ly1,lz1,lelv)
     $               ,wsy(lx1,ly1,lz1,lelv)
     $               ,wsz(lx1,ly1,lz1,lelv)
     $               ,vx_(lx1,ly1,lz1,lelv)
     $               ,term3x(lx1,ly1,lz1,lelv)
     $               ,convx(lx1,ly1,lz1,lelv)
     $               ,wintx(lx1,ly1,lz1,lelv)
     $               ,winty(lx1,ly1,lz1,lelv)
     $               ,wintz(lx1,ly1,lz1,lelv)
     $               ,wrhsx(lx1,ly1,lz1,lelv)
     $               ,wrhsy(lx1,ly1,lz1,lelv)
     $               ,wrhsz(lx1,ly1,lz1,lelv)
     $               ,psix(lx1,ly1,lz1,lelv)
     $               ,psiy(lx1,ly1,lz1,lelv)
     $               ,psiz(lx1,ly1,lz1,lelv)
     $               ,gpsix_x(lx1,ly1,lz1,lelv)
     $               ,gpsix_y(lx1,ly1,lz1,lelv)
     $               ,gpsix_z(lx1,ly1,lz1,lelv)
     $               ,gpsiy_x(lx1,ly1,lz1,lelv)
     $               ,gpsiy_y(lx1,ly1,lz1,lelv)
     $               ,gpsiy_z(lx1,ly1,lz1,lelv)
     $               ,gpsiz_x(lx1,ly1,lz1,lelv)
     $               ,gpsiz_y(lx1,ly1,lz1,lelv)
     $               ,gpsiz_z(lx1,ly1,lz1,lelv)
     $               ,psix_rhs(lx1,ly1,lz1,lelv)
     $               ,psiy_rhs(lx1,ly1,lz1,lelv)
     $               ,psiz_rhs(lx1,ly1,lz1,lelv)
      common /ransenrich/ wsk(lx1,ly1,lz1,lelv)
     $                  , wsomg(lx1,ly1,lz1,lelv)

      real wd
      common /walldist/ wd(lx1,ly1,lz1,lelv)

      real ypmin,ypmax,ypave,utmin,utmax,utave


c---------------------------------------------------------------
      if (mod(istep,10).eq.0) then
        call print_limits !monitor the solution
        call y_p_limits(wd,ypmin,ypmax,ypave,utmin,utmax,utave)
        if(nio.eq.0) then
          write(6,256)'y_p+',ypmin,ypmax,ypave
          write(6,256)'u_tau',utmin,utmax,utave
          write(6,*)
        endif
      endif

 256  format(a15,3es13.4)

C       save psix, psiy, psiz
c---------------------------------------------------------------

      n     = nx1*ny1*nz1*nelv
      nelx  = NUMBER_ELEMENTS_X
      nely  = NUMBER_ELEMENTS_Y
      nelz  = NUMBER_ELEMENTS_Z

      if (istep.eq.0) then
         bIDs(1) = 1
         call create_obj(iobj_wall,bIDs,1)
         nm = iglsum(nmember(iobj_wall),1)
         if(nid.eq.0) write(6,*) 'obj_wall nmem:', nm 
         call prepost(.true.,'  ')
      endif

      ubar = glsc2(vx,bm1,n)/volvm1
      e2   = glsc3(vy,bm1,vy,n)+glsc3(vz,bm1,vz,n)
      e2   = e2/volvm1
      if (nfield.gt.1) then
        tmn  = glmin(t,n)
        tmx  = glmax(t,n)
      endif
      if(nid.eq.0) write(6,2) time,ubar,e2,tmn,tmx
   2               format(1p5e13.4,' monitor')

c     WALL ENRICHMENT...START

      !if(nid.eq.0) write(6,*) "Perform wall enrichment"
      
c      call add3 (vx_,vx,psix,n) !calculate actual velocity

      use_default = 1

      if (istep.eq.0) then
          call oprzero(psix,psiy,psiz)
          call oprzero(gpsix_x,gpsix_y,gpsix_z)
          call oprzero(gpsiy_x,gpsiy_y,gpsiy_z)
          call oprzero(gpsiz_x,gpsiz_y,gpsiz_z)
         do iel = 1, nelv
          do ix = 1, lx1
           do iy = 1, ly1
            do iz = 1, lz1
               uti(ix,iy,iz,iel) = 0.08 ! Guess value for N-R solver
            enddo
           enddo
          enddo
         enddo
      endif

      ! Start enrichment at time 50
C       if (time.lt.50) then
      if (time.lt.50.0) then
        call oprzero(psix,psiy,psiz)
        call oprzero(psix_rhs,psiy_rhs,psiz_rhs)
        call oprzero(wsx,wsy,wsz)
        call oprzero(wintx,winty,wintz)
        call oprzero(wrhsx,wrhsy,wrhsz)
        call rzero(wsk, n)
        call rzero(wsomg,n)

      else

        if (comp_psi .ne. 1) then
C           if (use_default .eq. 1) then
C             comp_psi = 1 ! comment for adaptation
C           endif

          ! compute enrichment function psi
          if (secondcall .eq. 1) then
            call unprojenrich
          endif

C           do iel = 1, nelv
C             if ((flag(iel) .eq. 1) .or. (flag(iel) .eq. -1)) then  ! boundary element is above y=0
C                 do ix = 1,lx1
C                   do iz = 1,lz1
C C                     do iy = 1,ly1
C                     ! Get wall distance and y index
C                     if (flag(iel) .eq. 1) then
C                       iy = 1
C                       yp = 1-ym1(ix,iy,iz,iel)
C                       iy_ut = ly1
C                     else
C                       iy = ly1
C                       yp = 1+ym1(ix,iy,iz,iel)
C                       iy_ut = 1
C                     endif
C                     srbtest = uti(ix,iy_ut,iz,iel)
C                     avg_ind = ix+(iy-1)*lx1+(iz-1)*lx1*ly1+
C      $                 (iel-1)*lx1*ly1*lz1
C                     ! Use average value for matching point
C                     utau = newton(flg,ravg(avg_ind,1),yp,param(1),
C      $                 param(2),uti(ix,iy_ut,iz,iel),rtol,
C      $                 maxiter)
C                     if (utau .eq. 0.0) then
C                       count = count + 1 ! count unconverged solutions
C                       taunew(ix,iy,iz,iel) = -param(1)
C      $                                        *uti(ix,iy_ut,iz,iel)**2
C                     else
C                       uti(ix,iy_ut,iz,iel) = utau ! update guess value                  ! for next time step
C                       taunew(ix,iy_ut,iz,iel) = -param(1)*utau**2 ! shear stress
C                     endif
C                   enddo
C                 enddo
C              endif
C           enddo

          count = iglsum(count,1)

          if(nid.eq.0) then
            write(6,*) 'Solutions not converged: ', count
          endif

          count = 0


          ! Compute psix and grad_psi at nodes
          do iel = 1, nelv
            if ((flag(iel) .eq. 1) .or. (flag(iel) .eq. -1)) then  ! boundary element is above y=0
              if (flag(iel) .eq. 1) then
                iy_ut = ly1
              else
                iy_ut = 1
              endif
                do ix = 1,lx1
                  do iz = 1,lz1
                    do iy = 1,ly1
                      ut_param = uti(ix,iy_ut,iz,iel)
                      if (use_default .eq. 1) then
                        ut_param = utau_ref
                      endif
                      psix(ix,iy,iz,iel) = calc_psi(xm1(ix,iy,iz,iel),
     $                   ym1(ix,iy,iz,iel),zm1(ix,iy,iz,iel),flag(iel),
     $                   ut_param,param(2))
                      gpsix_y(ix,iy,iz,iel) = 
     $                   calc_gpsix_y(xm1(ix,iy,iz,iel),
     $                   ym1(ix,iy,iz,iel),zm1(ix,iy,iz,iel),flag(iel),
     $                   ut_param,param(2))
                    enddo
                  enddo
                enddo
             endif
          enddo

          ! Assume SEM basis in X and Z. Use analytical grad in y
          call gradm1(gpsix_x,phi_temp,gpsix_z,psix)

          ! Get enrichment values on boundary of enriched region
          ! Not currently used
C           call oprzero(psix_rhs,psiy_rhs,psiz_rhs)
C           do iel = 1, nelv
C             if (flag(iel) .eq. 2) then  ! boundary element is above y=0
C                 do ix = 1,lx1
C                   do iz = 1,lz1
C C                     do iy = 1,ly1
C                       iy = ly1
C                       ut_param = uti(ix,iy,iz,iel)
C                       if (use_default .eq. 1) then
C                         ut_param = utau_ref
C                       endif
C                       psix_rhs(ix,iy,iz,iel) = 
C      $                   calc_psi(xm1(ix,iy,iz,iel),
C      $                   ym1(ix,iy,iz,iel),zm1(ix,iy,iz,iel),flag(iel),
C      $                   ut_param,param(2))
C C                     enddo
C                   enddo
C                 enddo

C              else if (flag(iel) .eq. -2) then ! boundary element below y=0
C                  do ix = 1,lx1
C                   do iz = 1,lz1
C C                     do iy = 1,ly1
C                       iy = 1
C                       ut_param = uti(ix,iy,iz,iel)
C                       if (use_default .eq. 1) then
C                         ut_param = utau_ref
C                       endif
C                       psix_rhs(ix,iy,iz,iel) = 
C      $                   calc_psi(xm1(ix,iy,iz,iel),
C      $                   ym1(ix,iy,iz,iel),zm1(ix,iy,iz,iel),flag(iel),
C      $                   ut_param,param(2))
C C                     enddo
C                   enddo
C                  enddo
C              endif
C           enddo

C           call rzero  (tau_w,n)
C           do iel = 1, nelv
C             if (flag(iel) .eq. 1) then  ! boundary element is above y=0
C                 do ix = 1,lx1
C                   do iz = 1,lz1
C C                     do iy = 1,ly1
C                       iy = ly1
C                       ut_param = uti(ix,iy_ut,iz,iel)
C                       if (use_default .eq. 1) then
C                         ut_param = utau_ref
C                       endif
C                       tau_w(ix,iy,iz,iel) = -param(1)*ut_param*ut_param
C C                     enddo
C                   enddo
C                 enddo

C              else if (flag(iel) .eq. -1) then ! boundary element below y=0
C                  do ix = 1,lx1
C                   do iz = 1,lz1
C C                     do iy = 1,ly1
C                       iy = 1
C                       ut_param = uti(ix,iy_ut,iz,iel)
C                       if (use_default .eq. 1) then
C                         ut_param = utau_ref
C                       endif
C                       tau_w(ix,iy,iz,iel) = -param(1)*ut_param*ut_param
C C                     enddo
C                   enddo
C                  enddo
C              endif
C           enddo
        endif

        call projenrich
        if (secondcall .ne. 1) then
          secondcall = 1
          do ILAG = 2,NBD
            CALL COPY(VXLAG(1,1,1,1,ILAG-1),VX,n)
            CALL COPY(VYLAG(1,1,1,1,ILAG-1),VY,n)
            CALL COPY(VZLAG(1,1,1,1,ILAG-1),VZ,n)
          enddo
        endif

        if (comp_en_F.ne. 1) then
          ! comp_en_F = 1 ! This loop shouldn't be here. you always need it
          ! compute forcing terms in 3 directions
          call oprzero(wsx,wsy,wsz)

C           call add2   (wsx,tau_w,n)

          ! ----------------------------------------------------------------
          ! Term 2: -rho*dot(u0,gradient(psi))        M^psi,1 * u
          ! + Term 4: -rho*dot(psi,gradient(psi))     Should be zero

          ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ! M and T2 for x
          ! M^psi,2 * u or dot(gpsi, u)
          ! Should be zero in the simple case
          call copy (tx,gpsix_x,n)
          call copy (ty,gpsix_y,n)
          call copy (tz,gpsix_z,n)

          if (ldim == 2) call vdot2  (w1,vx,vy,tx,ty,n) !Term 2
          if (ldim == 3) call vdot3  (w1,vx,vy,vz,tx,ty,tz,n) !Term 2
          call copy   (tr2x,w1,n)
          call cmult  (tr2x,-1.0,n)
          ! Add to total forcing
          call add2   (wsx,w1,n)

          ! T^psi,2 or dot(psi,gpsi_x)
          ! Should be zero in the simple case
          if (ldim == 2) call vdot2  (w1,psix,psiy,tx,ty,n) !Term 4
          if (ldim == 3) call vdot3  (w1,psix,psiy,psiz,tx,ty,tz,n) !Term 4
          call copy   (tr4x,w1,n)
          call cmult  (tr4x,-1.0,n)
          ! Add to total forcing
          call add2   (wsx,w1,n)

          ! store gpsi_x
          call copy   (txx,tx,n)
          call copy   (txy,ty,n)
          call copy   (txz,tz,n)

          ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ! M and T2 for y
          ! M^psi,2 * v or dot(gpsi, v)
          call copy (tx,gpsiy_x,n)
          call copy (ty,gpsiy_y,n)
          call copy (tz,gpsiy_z,n)

          if (ldim == 2) call vdot2  (w1,vx,vy,tx,ty,n) !Term 2
          if (ldim == 3) call vdot3  (w1,vx,vy,vz,tx,ty,tz,n) !Term 2
          call copy   (tr2y,w1,n)
          call cmult  (tr2y,-1.0,n)
          ! Add to total forcing
          call add2   (wsy,w1,n)

          ! T^psi,2 or dot(psi,gpsi_y)
          ! Should be zero in the simple case
          if (ldim == 2) call vdot2  (w1,psix,psiy,tx,ty,n) !Term 4
          if (ldim == 3) call vdot3  (w1,psix,psiy,psiz,tx,ty,tz,n) !Term 4
          call copy   (tr4y,w1,n)
          call cmult  (tr4y,-1.0,n)
          ! Add to total forcing
          call add2   (wsy,w1,n)

          ! store gpsi_y
          call add2   (txy,tx,n)
          call copy   (tyy,ty,n)
          call copy   (tyz,tz,n)

          ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ! M and T2 for z
          ! M^psi,3 * w or dot(gpsi, w)
          ! Should be zero in the simple case
          call copy (tx,gpsiz_x,n)
          call copy (ty,gpsiz_y,n)
          call copy (tz,gpsiz_z,n)

          if (ldim == 2) call vdot2  (w1,vx,vy,tx,ty,n) !Term 2
          if (ldim == 3) call vdot3  (w1,vx,vy,vz,tx,ty,tz,n) !Term 2
          call copy   (tr2z,w1,n)
          call cmult  (tr2z,-1.0,n)
          ! Add to total forcing
          call add2   (wsz,w1,n)

          ! T^psi,2 or dot(psi,gpsi_z)
          ! Should be zero in the simple case
          if (ldim == 2) call vdot2  (w1,psix,psiy,tx,ty,n) !Term 4
          if (ldim == 3) call vdot3  (w1,psix,psiy,psiz,tx,ty,tz,n) !Term 4
          call copy   (tr4z,w1,n)
          call cmult  (tr4z,-1.0,n)
          ! Add to total forcing
          call add2   (wsz,w1,n)

          ! store gpsi_z
          call add2   (txz,tx,n)
          call add2   (tyz,ty,n)
          call copy   (tzz,tz,n)


          ! ----------------------------------------------------------------
          ! Term 3: -rho*dot(psi,gradient(u0))   S^psi

          ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ! S for x
          ! S^psi * u
          ! Compute grad of u
          call gradm1 (tx,ty,tz,vx)
          if (ldim == 2) call vdot2  (w1,psix,psiy,tx,ty,n) 
          if (ldim == 3) call vdot3  (w1,psix,psiy,psiz,tx,ty,tz,n) 
          call copy   (tr3x,w1,n)
          call cmult  (tr3x,-1.0,n)
          ! Add to total forcing
          call add2   (wsx,w1,n)

          ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ! S for y
          ! S^psi * v
          ! Compute grad of v
          call gradm1 (tx,ty,tz,vy)
          if (ldim == 2) call vdot2  (w1,psix,psiy,tx,ty,n) 
          if (ldim == 3) call vdot3  (w1,psix,psiy,psiz,tx,ty,tz,n) 
          call copy   (tr3y,w1,n)
          call cmult  (tr3y,-1.0,n)
          ! Add to total forcing
          call add2   (wsy,w1,n)

          ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ! S for z
          ! S^psi * w
          ! Compute grad of w
          call gradm1 (tx,ty,tz,vz)
          if (ldim == 2) call vdot2  (w1,psix,psiy,tx,ty,n) 
          if (ldim == 3) call vdot3  (w1,psix,psiy,psiz,tx,ty,tz,n) 
          call copy   (tr3z,w1,n)
          call cmult  (tr3z,-1.0,n)
          ! Add to total forcing
          call add2   (wsz,w1,n)

          ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ! multiply wsx,wsy,wsz by -rho
          call opcmult(wsx,wsy,wsz,-1.0)
          call opcolv (wsx,wsy,wsz,vtrans(1,1,1,1,1))

          ! ----------------------------------------------------------------
          ! Term 3: -rho*dot(psi,gradient(u0))   S^psi for RANS
          call rzero(wsk, n)
          call rzero(wsomg,n)

          ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ! S for x
          ! S^psi * k
          ! Compute grad of k
          call gradm1 (tx,ty,tz,t(1,1,1,1,ifld_k-1))
          if (ldim == 2) call vdot2  (w1,psix,psiy,tx,ty,n) 
          if (ldim == 3) call vdot3  (w1,psix,psiy,psiz,tx,ty,tz,n) 
C           call copy   (tr3x,w1,n)
C           call cmult  (tr3x,-1.0,n)
          ! Add to total forcing
          call add2   (wsk,w1,n)
          call cmult(wsk,-1.0,n)
          call cmult(wsk, vtrans(1,1,1,1,ifld_k-1),n)
          ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ! S for omg
          ! S^psi * omg
          ! Compute grad of omg
          call gradm1 (tx,ty,tz,t(1,1,1,1,ifld_omg-1))
          if (ldim == 2) call vdot2  (w1,psix,psiy,tx,ty,n) 
          if (ldim == 3) call vdot3  (w1,psix,psiy,psiz,tx,ty,tz,n) 
C           call copy   (tr3x,w1,n)
C           call cmult  (tr3x,-1.0,n)
          ! Add to total forcing
          call add2   (wsomg,w1,omg)
          call cmult(wsomg,-1.0,n)
          call cmult(wsomg, vtrans(1,1,1,1,ifld_omg-1),n)
        endif

        ! Compute T1 (viscous enrichment term)
        ! (nu*dot(grad phi, grad psi))
C         if (comp_T1 .ne. 1) then
C           if (use_default .eq. 1) then
C             comp_T1 = 1 ! Comment for adaptation
C           endif

C           call oprzero(wintx,winty,wintz)
C           call rzero  (T1_rhs_x,n)
C           call rzero  (T1_rhs_y,n)
C           call rzero  (T1_rhs_z,n)
C           call rzero  (tx,n)
C           call rzero  (ty,n)
C           call rzero  (tz,n)
C           call rzero  (w1,n)
C           call rzero  (w2,n)
C           call rzero  (w3,n)
C           call rzero  (phi_temp,n)

C           ! Compute phi grads of reference elements
C           if (comp_phi_grad .ne. 1) then
C             iz_end = lz1
C             if (ldim .eq. 2) then
C               iz_end = 1
C             endif
C             do iz = 1,lz1
C               do iy = 1,ly1
C                 do ix = 1,lx1
C                   ib = (iz-1)*lx1*ly1 + (iy-1)*(lx1) + ix
C                   call rzero(srb_temp,lx1*ly1*lz1*nelev)
C                   srb_temp(ix,iy,iz,1) = 1
C                   if (ldim .eq. 2) then           
C                     call local_grad2(dpdr(1,ib),
C      $                   dpds(1,ib),srb_temp,lx1-1,1,dxm1,dxtm1)
C                   elseif (ldim .eq. 3) then
C                     call local_grad3(dpdr(1,ib),
C      $                   dpds(1,ib),dpdt(1,ib),
C      $                   srb_temp,lx1-1,1,dxm1,dxtm1)
C                   endif
C                   srb_temp(ix,iy,iz,1) = 0   
C                 enddo
C               enddo
C             enddo
C           endif   

C           nb = lx1*ly1
C           if (ldim .eq. 3) then
C             nb = nb*lz1
C           endif
C           do iel = 1,nelv 
C             if ((flag(iel) .eq. 1) .or. (flag(iel) .eq. -1)) then
C               ! Compute phi grad
C               if (comp_phi_grad .ne. 1) then
C                 do j=1,nb ! actually nb
C                   do i=1,nb ! actually nq
C                    dpdx(j,i,iel)=jacmi(i,iel)*(dpdr(i,j)*rxm1(i,1,1,iel)
C      $                                     + dpds(i,j)*sxm1(i,1,1,iel)
C      $                                     + dpdt(i,j)*txm1(i,1,1,iel) )
C                    dpdy(j,i,iel)=jacmi(i,iel)*(dpdr(i,j)*rym1(i,1,1,iel)
C      $                                     + dpds(i,j)*sym1(i,1,1,iel)
C      $                                     + dpdt(i,j)*tym1(i,1,1,iel) )
C                    dpdz(j,i,iel)=jacmi(i,iel)*(dpdr(i,j)*rzm1(i,1,1,iel)
C      $                                     + dpds(i,j)*szm1(i,1,1,iel)
C      $                                     + dpdt(i,j)*tzm1(i,1,1,iel) )
C                   enddo
C                 enddo
C               endif
C               ! Compute other parts of T1
C               call col3(srb_temp,bm1(1,1,1,iel),vdiff(1,1,1,iel,1),nb)
C               call col3(tx,srb_temp,gpsix_x(1,1,1,iel),nb)
C               call col3(ty,srb_temp,gpsix_y(1,1,1,iel),nb)
C               call col3(tz,srb_temp,gpsix_z(1,1,1,iel),nb)
C               ! TODO: Add psiy and psiz parts

C               call mxm(dpdx(1,1,iel) ,nb,tx,nb,w1,1)
C               call mxm(dpdy(1,1,iel) ,nb,ty,nb,w2,1)
C               call mxm(dpdz(1,1,iel) ,nb,tz,nb,w3,1)

C               call cmult (w1,-1.,nb)
C               call cmult (w2,-1.,nb)
C               call cmult (w3,-1.,nb)

C               call cmult (w1,2.0,nb)

C               call add2(T1_rhs_x(1,1,1,iel),w1,nb)
C               call add2(T1_rhs_x(1,1,1,iel),w2,nb)
C               call add2(T1_rhs_x(1,1,1,iel),w3,nb)

C               ! Cross terms
C               call mxm(dpdx(1,1,iel) ,nb,ty,nb,w1,1)
C               call mxm(dpdx(1,1,iel) ,nb,tz,nb,w2,1)

C               call cmult (w1,-1.,nb)
C               call cmult (w2,-1.,nb)

C               call add2(T1_rhs_y(1,1,1,iel),w1,nb)
C               call add2(T1_rhs_z(1,1,1,iel),w2,nb)
C             endif
C           enddo
C           call add2 (wintx,T1_rhs_x,n)
C           call add2 (winty,T1_rhs_y,n)
C           call add2 (wintz,T1_rhs_z,n)

C           print *, "Print mu_t"
C           call srbprint(mutsk(1,1,1,1))
C           print *, "Print vdiff"
C           call srbprint(vdiff(1,1,1,1,1))
C           print *, "Print wintx"
C           call srbprint(wintx)
C           print *, "Print winty"
C           call srbprint(winty)  

C           ! only compute phi grads once
C           if (comp_phi_grad .ne. 1) then
C             comp_phi_grad = 1
C           endif
C         endif

      ! SRB REMOVE THIS TO ACTUALLY USE THE ENRICHMENT. THIS IS FOR TESTING
C       call oprzero(psix,psiy,psiz)
C       call oprzero(wsx,wsy,wsz)
C       call oprzero(wintx,winty,wintz)

      endif

c     WALL ENRICHMENT...END

      ifxyo = .true.
      if (istep.eq.0) call outfld('   ')
      if (istep.eq.0 .or. ifoutfld) then
         ! reconstruct velocity field
         call add3 (vx_,vx,psix,n) !calculate actual velocity
         call outpost(psix,psiy,psiz,vx_,t,'enr')
C          call outpost(psix,gpsix_y,psiz,vx_,t,'enr')
C          call outpost(tr1x,tr1y,tr1z,vx_,t,'Tr1')
C          call outpost(tr2x,tr2y,tr2z,vx_,t,'Tr2')
C          call outpost(tr3x,tr3y,tr3z,vx_,t,'Tr3')
C          call outpost(tr4x,tr4y,tr4z,vx_,t,'Tr4')
C          ifto = .true.
C          call outpost(wsx,wsy,wsz,term3x,convx,'src')
C          ifto = .false.
      endif


      if (time.lt.tSTATSTART) return


c     What follows computes some statistics ...
c

C       if(ifoutfld) then
C         if (ldimt.ge.2) call lambda2(t(1,1,1,1,2))
C         if (ldimt.ge.3) call comp_vort3(t(1,1,1,1,3),wo1,wo2,vx,vy,vz)
C       endif

      if(icalld.eq.0) then
        if(nid.eq.0) write(6,*) 'Start collecting statistics ...'

        nxm = 1 ! mesh is linear
        call interp_setup(intp_h,0.0,nxm,nelt)
        nint = 0
        if (nid.eq.0) then
          nint = INTP_NMAX
          call cfill(xint,XCINT,size(xint))
          do i = 1,INTP_NMAX 
             yi = (i-1.)/(INTP_NMAX-1)
             yint(i) = tanh(BETAM*(2*yi-1))/tanh(BETAM)
          enddo
          call cfill(zint,ZCINT,size(zint))

          do i = 1,INTP_NMAX 
            if (yint(i) < ym1(1,ly1,1,1)) then
              psix_int(i) = calc_psi(xint(i),yint(i),zint(i),-1,
     $                               utau_ref,param(2))
            elseif (yint(i) > ym1(1,1,1,nelv)) then
              psix_int(i) = calc_psi(xint(i),yint(i),zint(i),1,
     $                               utau_ref,param(2))
            else
              psix_int(i) = 0
            endif
          enddo
        endif
        iffpts = .true. ! dummy call to find points
        call interp_nfld(stat_y,ravg,1,xint,yint,zint,nint,
     $                   iwk,rwk,INTP_NMAX,iffpts,intp_h)
        iffpts = .false.
        call gtpp_gs_setup(igs_x,nelx     ,nely,nelz,1) ! x-avg
        if (ldim == 3) then
          call gtpp_gs_setup(igs_z,nelx*nely,1   ,nelz,3) ! z-avg
        endif

        call rzero(ravg,size(ravg))
        dragx_avg = 0
        dragx_avg_poly = 0
        atime     = 0
        timel     = time
        ntdump    = int(time/tSTATFREQ)

        icalld = 1
      endif

      dtime = time - timel
      atime = atime + dtime

      ! averaging over time
      if (atime.ne.0. .and. dtime.ne.0.) then
        beta      = dtime / atime
        alpha     = 1. - beta

        call unprojenrich
        ifverbose = .false.
        call avg1(ravg(1,1),vx   ,alpha,beta,n,'uavg',ifverbose)
        call avg2(ravg(1,2),vx   ,alpha,beta,n,'urms',ifverbose)
        call avg2(ravg(1,3),vy   ,alpha,beta,n,'vrms',ifverbose)
        call avg2(ravg(1,4),vz   ,alpha,beta,n,'wrms',ifverbose)
        call avg3(ravg(1,5),vx,vy,alpha,beta,n,'uvmm',ifverbose)

C         call avg1(ravg(1,6),t    ,alpha,beta,n,'tavg',ifverbose)
C         call avg2(ravg(1,7),t    ,alpha,beta,n,'trms',ifverbose)
C         call avg3(ravg(1,8),vx,t ,alpha,beta,n,'utmm',ifverbose)
C         call avg3(ravg(1,9),vy,t ,alpha,beta,n,'vtmm',ifverbose)

        call avg1(ravg(1,10),psix ,alpha,beta,n,'psix',ifverbose)
        call avg1(ravg(1,12),uti ,alpha,beta,n,'utia',ifverbose)
        call avg1(ravg(1,13),taunew ,alpha,beta,n,'taua',ifverbose)

        call torque_calc(1.0,x0,.false.,.false.) ! compute wall shear
        dragx_avg = alpha*dragx_avg + beta*dragx(iobj_wall)

        call projenrich
        call torque_calc(1.0,x0,.false.,.false.) ! compute wall shear
        dragx_avg_poly = alpha*dragx_avg_poly + beta*dragx(iobj_wall)
        
c        write(6,*) 'dragx(iobj_wall) = ', dragx(iobj_wall)
        call avg1(ravg(1,11),vx   ,alpha,beta,n,'upol',ifverbose)
      endif
      
C       write(6,*) 'dragx_avg = ', dragx_avg

      timel = time

      ! write statistics to file
      if(istep.gt.0 .and. time.gt.(ntdump+1)*tSTATFREQ) then
         ! averaging over statistical homogeneous directions (x-z)
         do i = 1,nstat
            call planar_avg(wo1      ,ravg(1,i),igs_x)
            call planar_avg(stat(1,i),wo1      ,igs_z)
         enddo

         ! Correct stat 9
         do iel = 1, nelv
            if (flag(iel) .eq. -1) then
              iy =  ly1
              do iz = 1, lz1
                do ix = 1, lx1
             j = (iel-1)*lx1*ly1*lz1 + (iz-1)*lx1*ly1 + (iy-1)*lx1 + ix
                  stat(j,10) = 2.0*stat(j,10)
                  stat(j,11) = stat(j,11) - stat(j,10)/2.0
                enddo
              enddo
            elseif (flag(iel) .eq. -2) then
              iy =  1
              do iz = 1, lz1
                do ix = 1, lx1
             j = (iel-1)*lx1*ly1*lz1 + (iz-1)*lx1*ly1 + (iy-1)*lx1 + ix
                  stat(j,11) = stat(j,11) + stat(j,10)
                  stat(j,10) = 0.0
                enddo
              enddo
            elseif (flag(iel) .eq. 2) then
              iy = ly1
              do iz = 1, lz1
                do ix = 1, lx1
             j = (iel-1)*lx1*ly1*lz1 + (iz-1)*lx1*ly1 + (iy-1)*lx1 + ix
                  stat(j,11) = stat(j,11) + stat(j,10)
                  stat(j,10) = 0.0
                enddo
              enddo  
            elseif (flag(iel) .eq. 1) then
              iy =  1
              do iz = 1, lz1
                do ix = 1, lx1
             j = (iel-1)*lx1*ly1*lz1 + (iz-1)*lx1*ly1 + (iy-1)*lx1 + ix
                  stat(j,10) = 2.0*stat(j,10)
                  stat(j,11) = stat(j,11) - stat(j,10)/2.0
                enddo
              enddo  
            endif 
          enddo

         if (nfield.gt.1) then
            ! evaluate d<T>/dy at the lower wall
C             call opgrad(wo1,wo2,wo3,stat(1,6))
C             call dssum(wo2,lx1,ly1,lz1)
C             call col2(wo2,binvm1,n)
C             call interp_nfld(stat_y,wo2,1,xint,yint,zint,nint,
C      $                       iwk,rwk,INTP_NMAX,iffpts,intp_h)
C             dTdy_w = stat_y(1)
         else
            dTdy_w = 1.
         endif

         ! extract data along wall normal direction (1D profile)
         call interp_nfld(stat_y,stat,nstat,xint,yint,zint,nint,
     $                    iwk,rwk,INTP_NMAX,iffpts,intp_h)

         ntdump = ntdump + 1
         if (nid.ne.0) goto 998 

         ! Interpolate psi at all points
         ut_param = (stat_y(11*nint+1) + stat_y(11*nint+nint))/2.0
         tau_param = (stat_y(12*nint+1) + stat_y(12*nint+nint))/2.0
         if (use_default .eq. 1) then
               ut_param = utau_ref
         endif
         do i = 1,INTP_NMAX 
           if (yint(i) < bot_y) then
             psix_int(i) = calc_psi(xint(i),yint(i),zint(i),-1,
     $                              ut_param,param(2))
           elseif (yint(i) > top_y) then
             psix_int(i) = calc_psi(xint(i),yint(i),zint(i),1,
     $                              ut_param,param(2))
           else
             psix_int(i) = 0
           endif
         enddo 

         rho    = param(1)
         dnu    = param(2)
         A_w    = 2 * XLEN 
         if (ldim == 3) A_w = A_w*ZLEN
         tw     = dragx_avg / A_w
         u_tau  = sqrt(tw / rho)
         tw_poly     = dragx_avg_poly / A_w
         u_tau_poly  = sqrt(tw_poly / rho)
         qw     = -param(8) * dTdy_w
         t_tau  = 1/u_tau * qw
         Re_tau = u_tau / dnu
         tplus  = time * u_tau**2 / dnu

         write(6,*) 'u_taus ...', ut_param, u_tau, u_tau_poly
     $    u_tau, tw, tw_poly, tau_param, A_w

         write(6,*) 'Dumping statistics ...', Re_tau, t_tau, dragx_avg,
     $    u_tau
 
         open(unit=56,file='vel_fluc_prof.dat')
         write(56,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', ut_param 
         write(56,'(A)') 
     $    '%  y    y+    uu    vv    ww    uv    u_tau'

         open(unit=57,file='mean_prof.dat')
         write(57,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', ut_param, 
     $     '%u_tau_poly = ', u_tau_poly
         write(57,'(A)') 
     $    '%  y    y+    Umean    Psimean  Upolymean    Psi   u_tau'

         do i = 1,nint
            yy = 1+yint(i)
            write(56,3) 
     &           yy,
     &           yy*Re_tau,
     &           (stat_y(1*nint+i)-(stat_y(0*nint+i))**2),
     &           stat_y(2*nint+i),
     &           stat_y(3*nint+i),
     &           stat_y(4*nint+i),
     &           u_tau

            write(57,3) 
     &           yy,
     &           yy*Re_tau, 
     &           stat_y(0*nint+i),
     &           stat_y(9*nint+i),
     &           stat_y(10*nint+i),
     &           psix_int(i),
     &           u_tau

  3         format(1p15e17.9)
         enddo
         close(56)
         close(57)

 998  endif

      return
      end

c-----------------------------------------------------------------------
      subroutine userchk2 ()
      include 'SIZE'
      include 'TOTAL'
      include 'RANS_KOMG'

      integer ILAG

      real x0(3)
      data x0 /0.0, 0.0, 0.0/ 
      save x0

      integer icalld
      save    icalld
      data    icalld /0/

      real atime,timel
      save atime,timel

      integer ntdump
      save    ntdump

      real    rwk(INTP_NMAX,ldim+1) ! r, s, t, dist2
      integer iwk(INTP_NMAX,3)      ! code, proc, el 
      save    rwk, iwk

      integer nint, intp_h
      save    nint, intp_h

      logical iffpts
      save iffpts

      real xint(INTP_NMAX),yint(INTP_NMAX),zint(INTP_NMAX)
      save xint, yint, zint
      save igs_x, igs_z

      parameter(nstat=13)
      real ravg(lx1*ly1*lz1*lelt,nstat)
      real stat(lx1*ly1*lz1*lelt,nstat)
      real stat_y(INTP_NMAX*nstat)
      save ravg, stat, stat_y

      save dragx_avg, dragx_avg_poly
      real tw_poly, u_tau_poly

      logical ifverbose
      common /gaaa/    wo1(lx1,ly1,lz1,lelv)
     &              ,  wo2(lx1,ly1,lz1,lelv)
     &              ,  wo3(lx1,ly1,lz1,lelv)

      integer flag(lelv)
      common /beflag/ flag

c----------------------------------------------------------------
c     VARIABLES DECLARED FOR USING THE NON-ITERATIVE METHOD  
      real tauold(lx1,ly1,lz1,lelv), taunew(lx1,ly1,lz1,lelv)
      common /wallshear/ taunew
      save tauold
      
      real M, Kappa, utau_init
      data M/5.17/, kappa/0.41/, utau_init/0.2/
      save M, kappa, utau_init
c----------------------------------------------------------------
c     VARIABLES DECLARED FOR USING THE ITERATIVE METHOD 
      real newton,secant,rtol,ut0,ut1,uti(lx1,ly1,lz1,lelv),utau
      integer flg, maxiter, count
      data rtol/1.0e-5/, maxiter/20000/
      data flg/2/, count/0/ !flg = flag for the chosen wall model
c      data uti/0.2/  !Initial guess value of utau for Newton Method
      data ut0/0.04/, ut1/0.08/ !Initial guess values for Secant Method
      save rtol, maxiter, flg, uti, ut0, ut1
c---------------------------------------------------------------

      real tplus
      real tmn, tmx   

      integer bIDs(1)
      save iobj_wall

c---------------------------------------------------------------
c     VARIABLES DECLARED FOR ENRICHMENT METHOD
      integer secondcall
      save secondcall
      real utau_ref, Re_tau
C       real psix(lx1,ly1,lz1,lelv)
C       real gpsix_x(lx1,ly1,lz1,lelv), gpsix_y(lx1,ly1,lz1,lelv)
C       real gpsix_z(lx1,ly1,lz1,lelv), gpsiy_x(lx1,ly1,lz1,lelv)
C       real gpsiy_y(lx1,ly1,lz1,lelv), gpsiy_z(lx1,ly1,lz1,lelv)
C       real gpsiz_x(lx1,ly1,lz1,lelv), gpsiz_y(lx1,ly1,lz1,lelv)
C       real gpsiz_z(lx1,ly1,lz1,lelv)
C       real psiy(lx1,ly1,lz1,lelv), psiz(lx1,ly1,lz1,lelv) 
      real myH1(lx1,ly1,lz1,lelv), myH2(lx1,ly1,lz1,lelv) 
      real myH1_rhs(lx1,ly1,lz1,lelv), myH2_rhs(lx1,ly1,lz1,lelv) 
      real phi_temp(lx1,ly1,lz1,lelv), T1_rhs_x(lx1,ly1,lz1,lelv) 
      real T1_rhs_y(lx1,ly1,lz1,lelv), T1_rhs_z(lx1,ly1,lz1,lelv) 
      save T1_rhs_x, T1_rhs_y, T1_rhs_z
      save T1_rhs
      integer comp_T1, comp_en_F, comp_psi, iy_ut, avg_ind, use_default
      save comp_T1, comp_en_F, comp_psi
      real tau_w(lx1,ly1,lz1,lelv)
      real srb_temp(lx1,ly1,lz1,lelv)
      integer ib, ib2, iz_end
      real srbtest, ut_param, tau_param
      real psix_int(INTP_NMAX)
      save psix_int
      integer comp_phi_grad
      save comp_phi_grad
      integer nb
      common /phigrad/ dpdr(lx1*ly1*lz1,lx1*ly1*lz1)
     $                ,dpds(lx1*ly1*lz1,lx1*ly1*lz1)
     $                ,dpdt(lx1*ly1*lz1,lx1*ly1*lz1)
     $                ,dpdx(lx1*ly1*lz1,lx1*ly1*lz1,lelv)
     $                ,dpdy(lx1*ly1*lz1,lx1*ly1*lz1,lelv)
     $                ,dpdz(lx1*ly1*lz1,lx1*ly1*lz1,lelv)
                               !(nb,nq)
      data utau_ref/5.43496e-02/  !Assumed constant value of u_tau
      common /y_ends/ bot_y, top_y
      real w1(lx1,ly1,lz1,lelv)
     $              ,w2(lx1,ly1,lz1,lelv)
     $              ,w3(lx1,ly1,lz1,lelv)
     $              ,tx(lx1,ly1,lz1,lelv)
     $              ,ty(lx1,ly1,lz1,lelv)
     $              ,tz(lx1,ly1,lz1,lelv)
      real txx(lx1,ly1,lz1,lelv)
     $               ,tyy(lx1,ly1,lz1,lelv)
     $               ,tzz(lx1,ly1,lz1,lelv)
     $               ,txy(lx1,ly1,lz1,lelv)
     $               ,tyz(lx1,ly1,lz1,lelv)
     $               ,txz(lx1,ly1,lz1,lelv)
     $               ,tr1x(lx1,ly1,lz1,lelv)
     $               ,tr1y(lx1,ly1,lz1,lelv)
     $               ,tr1z(lx1,ly1,lz1,lelv)
     $               ,tr2x(lx1,ly1,lz1,lelv)
     $               ,tr2y(lx1,ly1,lz1,lelv)
     $               ,tr2z(lx1,ly1,lz1,lelv)
     $               ,tr3x(lx1,ly1,lz1,lelv)
     $               ,tr3y(lx1,ly1,lz1,lelv)
     $               ,tr3z(lx1,ly1,lz1,lelv)
     $               ,tr4x(lx1,ly1,lz1,lelv)
     $               ,tr4y(lx1,ly1,lz1,lelv)
     $               ,tr4z(lx1,ly1,lz1,lelv)
      common /enrich/ wsx(lx1,ly1,lz1,lelv)
     $               ,wsy(lx1,ly1,lz1,lelv)
     $               ,wsz(lx1,ly1,lz1,lelv)
     $               ,vx_(lx1,ly1,lz1,lelv)
     $               ,term3x(lx1,ly1,lz1,lelv)
     $               ,convx(lx1,ly1,lz1,lelv)
     $               ,wintx(lx1,ly1,lz1,lelv)
     $               ,winty(lx1,ly1,lz1,lelv)
     $               ,wintz(lx1,ly1,lz1,lelv)
     $               ,wrhsx(lx1,ly1,lz1,lelv)
     $               ,wrhsy(lx1,ly1,lz1,lelv)
     $               ,wrhsz(lx1,ly1,lz1,lelv)
     $               ,psix(lx1,ly1,lz1,lelv)
     $               ,psiy(lx1,ly1,lz1,lelv)
     $               ,psiz(lx1,ly1,lz1,lelv)
     $               ,gpsix_x(lx1,ly1,lz1,lelv)
     $               ,gpsix_y(lx1,ly1,lz1,lelv)
     $               ,gpsix_z(lx1,ly1,lz1,lelv)
     $               ,gpsiy_x(lx1,ly1,lz1,lelv)
     $               ,gpsiy_y(lx1,ly1,lz1,lelv)
     $               ,gpsiy_z(lx1,ly1,lz1,lelv)
     $               ,gpsiz_x(lx1,ly1,lz1,lelv)
     $               ,gpsiz_y(lx1,ly1,lz1,lelv)
     $               ,gpsiz_z(lx1,ly1,lz1,lelv)
     $               ,psix_rhs(lx1,ly1,lz1,lelv)
     $               ,psiy_rhs(lx1,ly1,lz1,lelv)
     $               ,psiz_rhs(lx1,ly1,lz1,lelv)
      common /ransenrich/ wsk(lx1,ly1,lz1,lelv)
     $                  , wsomg(lx1,ly1,lz1,lelv)

      real wd
      common /walldist/ wd(lx1,ly1,lz1,lelv)

      real ypmin,ypmax,ypave,utmin,utmax,utave


c---------------------------------------------------------------
C       if (mod(istep,10).eq.0) then
C         call print_limits !monitor the solution
C         call y_p_limits(wd,ypmin,ypmax,ypave,utmin,utmax,utave)
C         if(nio.eq.0) then
C           write(6,256)'y_p+',ypmin,ypmax,ypave
C           write(6,256)'u_tau',utmin,utmax,utave
C           write(6,*)
C         endif
C       endif

C  256  format(a15,3es13.4)

C       save psix, psiy, psiz
c---------------------------------------------------------------

      n     = nx1*ny1*nz1*nelv
      nelx  = NUMBER_ELEMENTS_X
      nely  = NUMBER_ELEMENTS_Y
      nelz  = NUMBER_ELEMENTS_Z

C       if (istep.eq.0) then
C          bIDs(1) = 1
C          call create_obj(iobj_wall,bIDs,1)
C          nm = iglsum(nmember(iobj_wall),1)
C          if(nid.eq.0) write(6,*) 'obj_wall nmem:', nm 
C          call prepost(.true.,'  ')
C       endif

C       ubar = glsc2(vx,bm1,n)/volvm1
C       e2   = glsc3(vy,bm1,vy,n)+glsc3(vz,bm1,vz,n)
C       e2   = e2/volvm1
C       if (nfield.gt.1) then
C         tmn  = glmin(t,n)
C         tmx  = glmax(t,n)
C       endif
C       if(nid.eq.0) write(6,2) time,ubar,e2,tmn,tmx
C    2               format(1p5e13.4,' monitor')

c     WALL ENRICHMENT...START

      !if(nid.eq.0) write(6,*) "Perform wall enrichment"
      
c      call add3 (vx_,vx,psix,n) !calculate actual velocity

      use_default = 1

      if (istep.eq.0) then
          call oprzero(psix,psiy,psiz)
          call oprzero(gpsix_x,gpsix_y,gpsix_z)
          call oprzero(gpsiy_x,gpsiy_y,gpsiy_z)
          call oprzero(gpsiz_x,gpsiz_y,gpsiz_z)
         do iel = 1, nelv
          do ix = 1, lx1
           do iy = 1, ly1
            do iz = 1, lz1
               uti(ix,iy,iz,iel) = 0.08 ! Guess value for N-R solver
            enddo
           enddo
          enddo
         enddo
      endif

      ! Start enrichment at time 50
C       if (time.lt.50) then
      if (time.lt.0.0) then
        call oprzero(psix,psiy,psiz)
        call oprzero(psix_rhs,psiy_rhs,psiz_rhs)
        call oprzero(wsx,wsy,wsz)
        call oprzero(wintx,winty,wintz)
        call oprzero(wrhsx,wrhsy,wrhsz)
        call rzero(wsk, n)
        call rzero(wsomg,n)

      else
        ! Compute T1 (viscous enrichment term)
        ! (nu*dot(grad phi, grad psi))
        if (comp_T1 .ne. 1) then
C           if (use_default .eq. 1) then
C             comp_T1 = 1 ! Comment for adaptation
C           endif

          call oprzero(wintx,winty,wintz)
          call rzero  (T1_rhs_x,n)
          call rzero  (T1_rhs_y,n)
          call rzero  (T1_rhs_z,n)
          call rzero  (tx,n)
          call rzero  (ty,n)
          call rzero  (tz,n)
          call rzero  (w1,n)
          call rzero  (w2,n)
          call rzero  (w3,n)
          call rzero  (phi_temp,n)

          ! Compute phi grads of reference elements
          if (comp_phi_grad .ne. 1) then
            iz_end = lz1
            if (ldim .eq. 2) then
              iz_end = 1
            endif
            do iz = 1,lz1
              do iy = 1,ly1
                do ix = 1,lx1
                  ib = (iz-1)*lx1*ly1 + (iy-1)*(lx1) + ix
                  call rzero(srb_temp,lx1*ly1*lz1*nelev)
                  srb_temp(ix,iy,iz,1) = 1
                  if (ldim .eq. 2) then           
                    call local_grad2(dpdr(1,ib),
     $                   dpds(1,ib),srb_temp,lx1-1,1,dxm1,dxtm1)
                  elseif (ldim .eq. 3) then
                    call local_grad3(dpdr(1,ib),
     $                   dpds(1,ib),dpdt(1,ib),
     $                   srb_temp,lx1-1,1,dxm1,dxtm1)
                  endif
                  srb_temp(ix,iy,iz,1) = 0   
                enddo
              enddo
            enddo
          endif   

          nb = lx1*ly1
          if (ldim .eq. 3) then
            nb = nb*lz1
          endif
          do iel = 1,nelv 
            if ((flag(iel) .eq. 1) .or. (flag(iel) .eq. -1)) then
              ! Compute phi grad
              if (comp_phi_grad .ne. 1) then
                do j=1,nb ! actually nb
                  do i=1,nb ! actually nq
                   dpdx(j,i,iel)=jacmi(i,iel)*(dpdr(i,j)*rxm1(i,1,1,iel)
     $                                     + dpds(i,j)*sxm1(i,1,1,iel)
     $                                     + dpdt(i,j)*txm1(i,1,1,iel) )
                   dpdy(j,i,iel)=jacmi(i,iel)*(dpdr(i,j)*rym1(i,1,1,iel)
     $                                     + dpds(i,j)*sym1(i,1,1,iel)
     $                                     + dpdt(i,j)*tym1(i,1,1,iel) )
                   dpdz(j,i,iel)=jacmi(i,iel)*(dpdr(i,j)*rzm1(i,1,1,iel)
     $                                     + dpds(i,j)*szm1(i,1,1,iel)
     $                                     + dpdt(i,j)*tzm1(i,1,1,iel) )
                  enddo
                enddo
              endif
              ! Compute other parts of T1
              call col3(srb_temp,bm1(1,1,1,iel),vdiff(1,1,1,iel,1),nb)
              call col3(tx,srb_temp,gpsix_x(1,1,1,iel),nb)
              call col3(ty,srb_temp,gpsix_y(1,1,1,iel),nb)
              call col3(tz,srb_temp,gpsix_z(1,1,1,iel),nb)
              ! TODO: Add psiy and psiz parts

              call mxm(dpdx(1,1,iel) ,nb,tx,nb,w1,1)
              call mxm(dpdy(1,1,iel) ,nb,ty,nb,w2,1)
              call mxm(dpdz(1,1,iel) ,nb,tz,nb,w3,1)

              call cmult (w1,-1.,nb)
              call cmult (w2,-1.,nb)
              call cmult (w3,-1.,nb)

              call cmult (w1,2.0,nb)

              call add2(T1_rhs_x(1,1,1,iel),w1,nb)
              call add2(T1_rhs_x(1,1,1,iel),w2,nb)
              call add2(T1_rhs_x(1,1,1,iel),w3,nb)

              ! Cross terms
              call mxm(dpdx(1,1,iel) ,nb,ty,nb,w1,1)
              call mxm(dpdx(1,1,iel) ,nb,tz,nb,w2,1)

              call cmult (w1,-1.,nb)
              call cmult (w2,-1.,nb)

              call add2(T1_rhs_y(1,1,1,iel),w1,nb)
              call add2(T1_rhs_z(1,1,1,iel),w2,nb)
            endif
          enddo
          call add2 (wintx,T1_rhs_x,n)
          call add2 (winty,T1_rhs_y,n)
          call add2 (wintz,T1_rhs_z,n)

          ! only compute phi grads once
          if (comp_phi_grad .ne. 1) then
            comp_phi_grad = 1
          endif
        endif

      ! SRB REMOVE THIS TO ACTUALLY USE THE ENRICHMENT. THIS IS FOR TESTING
C       call oprzero(psix,psiy,psiz)
C       call oprzero(wsx,wsy,wsz)
C       call oprzero(wintx,winty,wintz)

      endif

c     WALL ENRICHMENT...END

      return
      end

c-----------------------------------------------------------------------
      subroutine userqtl ! Set thermal divergence

      call userqtl_scig 

      return

      end
c-----------------------------------------------------------------------
      subroutine srbrhs ()
      ! Compute forcing term added directly to RHS for continuity
      ! Not currently needed for continuity
      include 'SIZE'
      include 'TOTAL'

      integer flag(lelv)
      common /beflag/ flag

c---------------------------------------------------------------
c     VARIABLES DECLARED FOR ENRICHMENT METHOD
      real myH1(lx1,ly1,lz1,lelv), myH2(lx1,ly1,lz1,lelv) 
      real myH1_rhs(lx1,ly1,lz1,lelv), myH2_rhs(lx1,ly1,lz1,lelv) 
      real phi_temp(lx1,ly1,lz1,lelv), T1_rhs(lx1,ly1,lz1,lelv)
      real w1(lx1,ly1,lz1,lelv)
     $              ,w2(lx1,ly1,lz1,lelv)
     $              ,w3(lx1,ly1,lz1,lelv)
      common /enrich/ wsx(lx1,ly1,lz1,lelv)
     $               ,wsy(lx1,ly1,lz1,lelv)
     $               ,wsz(lx1,ly1,lz1,lelv)
     $               ,vx_(lx1,ly1,lz1,lelv)
     $               ,term3x(lx1,ly1,lz1,lelv)
     $               ,convx(lx1,ly1,lz1,lelv)
     $               ,wintx(lx1,ly1,lz1,lelv)
     $               ,winty(lx1,ly1,lz1,lelv)
     $               ,wintz(lx1,ly1,lz1,lelv)
     $               ,wrhsx(lx1,ly1,lz1,lelv)
     $               ,wrhsy(lx1,ly1,lz1,lelv)
     $               ,wrhsz(lx1,ly1,lz1,lelv)
     $               ,psix(lx1,ly1,lz1,lelv)
     $               ,psiy(lx1,ly1,lz1,lelv)
     $               ,psiz(lx1,ly1,lz1,lelv)
     $               ,gpsix_x(lx1,ly1,lz1,lelv)
     $               ,gpsix_y(lx1,ly1,lz1,lelv)
     $               ,gpsix_z(lx1,ly1,lz1,lelv)
     $               ,gpsiy_x(lx1,ly1,lz1,lelv)
     $               ,gpsiy_y(lx1,ly1,lz1,lelv)
     $               ,gpsiy_z(lx1,ly1,lz1,lelv)
     $               ,gpsiz_x(lx1,ly1,lz1,lelv)
     $               ,gpsiz_y(lx1,ly1,lz1,lelv)
     $               ,gpsiz_z(lx1,ly1,lz1,lelv)
     $               ,psix_rhs(lx1,ly1,lz1,lelv)
     $               ,psiy_rhs(lx1,ly1,lz1,lelv)
     $               ,psiz_rhs(lx1,ly1,lz1,lelv)

C       save psix, psiy, psiz
c---------------------------------------------------------------

      n     = nx1*ny1*nz1*nelv
      nelx  = NUMBER_ELEMENTS_X
      nely  = NUMBER_ELEMENTS_Y
      nelz  = NUMBER_ELEMENTS_Z

c     WALL ENRICHMENT...START
      call oprzero(wrhsx,wrhsy,wrhsz)
      ! Continuity forcing term   
      INTYPE = -1
      call rzero  (myH1,n)
      call rzero  (myH2,n)
      CALL SETHLM  (myH1,myH2,INTYPE) ! won't work for first few steps
C       ntot1 = lx1*ly1*lz1*nelv
C       call copy  (myH1,vdiff (1,1,1,1,1),ntot1)
C       call copy  (myH2,vtrans(1,1,1,1,1),ntot1)
C       dtbd = bd(1)/dt
C       call cmult (myH2,dtbd,ntot1) ! Call this later

      ! To add columns together, create a vector with only nonzeros
      ! in rows with, so we are multiplying those columns of 
      ! H1*A and H1*B by psi and adding the results
      ! This accounts for the direct stiffness sum of the offset in the 
      ! coefficients at the enrichment interface
      nelx  = NUMBER_ELEMENTS_X
      call rzero  (w1,n)
C       call rzero  (w2,n)
C       call rzero  (w3,n)
      do iel = 1, nelv
        if (flag(iel) .eq. 2) then  ! boundary element is above y=0
            do ix = 1,lx1
              do iz = 1,lz1
C                 do iy = 1,ly1
C                   iy = ly1
C                   iy_psi = 1
C                   w1(ix,iy,iz,iel) = -psix_rhs(ix,iy_psi,iz,iel)
C                   w2(ix,iy,iz,iel) = -psiy_rhs(ix,iy_psi,iz,iel)
C                   w3(ix,iy,iz,iel) = -psiz_rhs(ix,iy_psi,iz,iel)
C                 enddo
              enddo
            enddo

         elseif (flag(iel) .eq. -2) then ! boundary element below y=0
            do ix = 1,lx1
              do iz = 1,lz1
C                 do iy = 1,ly1
                  iy = 1
                  iy_psi = ly1
                  w1(ix,iy,iz,iel) = -psix_rhs(ix,iy_psi,iz,iel)
C                   w2(ix,iy,iz,iel) = -psiy_rhs(ix,iy_psi,iz,iel)
C                   w3(ix,iy,iz,iel) = -psiz_rhs(ix,iy_psi,iz,iel)
C                 enddo
              enddo
            enddo
         endif
      enddo
      ! Multiply phi_temp by Helmholz matrices to extract columns 
      ! multiplied by psi
      call axhelm(wrhsx,w1,myH1,myH2,1,1)
C       call axhelm(wrhsy,w2,myH1,myH2,1,1)
C       call axhelm(wrhsz,w3,myH1,myH2,1,1)

      ! SRB REMOVE THIS TO ACTUALLY USE THE ENRICHMENT. THIS IS FOR TESTING
C       call oprzero(wrhsx,wrhsy,wrhsz)

c     WALL ENRICHMENT...END

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      real taunew(lx1,ly1,lz1,lelv)
      common /wallshear/ taunew

C       if (y.lt.0) temp = 1.0
C       if (y.gt.0) temp = 0.0

      e = gllel(ieg)

      if((cbc(iside,e,1).eq.'v  ') .or. (cbc(iside,e,1).eq.'V  ')) then
        UX=0.0
        UY=0.0
        UZ=0.0
        temp=0.0
        ! This isn't actually used
        TRX=-param(1)*(5.43496e-02)*(5.43496e-02) !taunew(ix,iy,iz,e)
        TRY=0.0
        TRZ=0.0
      endif

c     Imposing shear stress B.C.s
      if(cbc(iside,e,1).eq.'sh ') then
        TRX=taunew(ix,iy,iz,e) !-param(1)*(5.43496e-02)*(5.43496e-02) !taunew(ix,iy,iz,e)
        TRY=0.0
        TRZ=0.0
        temp=0.0
      endif
      
      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,eg)
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      real wd
      common /walldist/ wd(lx1,ly1,lz1,lelv)

      integer ix,iy,iz,e,eg
      real darcy,utau,sigm,kmax,omax,yplus,fact,Re

      e = gllel(eg)

      Re    = 1.0/param(2)
      darcy = 0.316/(Re**0.25)
      utau  = sqrt(darcy/8.0)
      sigm  = 0.6
      kmax  = 4.5*utau*utau
      omax  = 0.5*utau*utau*Re
      yplus = max(wd(ix,iy,iz,e)*utau*Re,1.0e-3)

      ux   = 3.0/2.0*(1.0-y*y)
      uy   = 0.0
      uz   = 0.0
      temp = 0.0

      fact = exp(-(log10(yplus)-1.0)**2/(2.0*sigm**2))
      if(ifield.eq.3) temp = kmax*fact
      if(ifield.eq.4) temp = omax*fact

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat ()   ! This routine to modify element vertices
      include 'SIZE'      ! _before_ mesh is generated, which 
      include 'TOTAL'     ! guarantees GLL mapping of mesh.

      real wd
      common /walldist/ wd(lx1,ly1,lz1,lelv)
c      param(84) = 1e-6    ! setting initial time step

      n = nelv * 8 !2**ldim
      xmin = glmin(xc,n)
      xmax = glmax(xc,n)
      ymin = glmin(yc,n)
      ymax = glmax(yc,n)
      zmin = glmin(zc,n)
      zmax = glmax(zc,n)

      xscale = XLEN/(xmax-xmin)
      yscale = 1./(ymax-ymin)
      zscale = ZLEN/(zmax-zmin)

      do i=1,n
         xc(i,1) = xscale*xc(i,1)
         yc(i,1) = 2*yscale*yc(i,1)-1.  ! No stretching 
         !yc(i,1) = tanh(BETAM*(2*yscale*yc(i,1)-1))/tanh(BETAM) ! Stretching
        if (ldim == 3) then
         zc(i,1) = zscale*zc(i,1)
        endif
      enddo
C       do i=1,n
C          xc(i,1) = xscale*xc(i,1)
C          yc(i,1) = 2*yscale*yc(i,1)-1  ! No stretching 
C          !yc(i,1) = tanh(BETAM*(2*yscale*yc(i,1)-1))/tanh(BETAM) ! Stretching
C         if (ldim == 3) then
C          zc(i,1) = zscale*zc(i,1)
C         endif
C       enddo

c     calculate wall distance for regularized k-omega
C       call rone(wd,n)
C       call abssub2(wd,ym1,n)
 
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2 () ! This routine to modify mesh coordinates
      include 'SIZE'
      include 'TOTAL'
      
      integer flag(lelv), counterp, countern, counterp2, countern2
      common /beflag/ flag
      common /y_ends/ bot_y, top_y
      
      counterp = 0
      countern = 0
      counterp2 = 0
      countern2 = 0

      ! Label boundary elements
      do iel=1,nelt
      do ifc=1,2*ndim
         if ((cbc(ifc,iel,1) .eq. 'sh ') .or. 
     $       (cbc(ifc,iel,1) .eq. 'W  ') .or. 
     $       (cbc(ifc,iel,1) .eq. 'V  ')) then 
           boundaryID(ifc,iel) = 1
         endif 
         cbc(ifc,iel,2) = cbc(ifc,iel,1) 
         if ((cbc(ifc,iel,1) .eq. 'sh ') .or. 
     $       (cbc(ifc,iel,1) .eq. 'W  ') .or.
     $       (cbc(ifc,iel,1) .eq. 'V  ')) then 
           cbc(ifc,iel,2) = 't  '
         endif
      enddo
      enddo

      ! Label boundary elements 
      ! Flag boundary elements above and below centerline (y = 0)
      nelx  = NUMBER_ELEMENTS_X
      nely  = NUMBER_ELEMENTS_Y
      nelz  = NUMBER_ELEMENTS_Z
      do iel=1,nelv
         do ifc=1,2*ldim
           if (((cbc(ifc,iel,1) .eq. 'sh ') .or. 
     $          (cbc(ifc,iel,1) .eq. 'W  ') .or.
     $          (cbc(ifc,iel,1) .eq. 'V  ')).AND.(ym1(1,1,1,iel).gt.0)) 
     $          then
              flag(iel) = 1
              top_y = ym1(1,1,1,iel)
           else if (((cbc(ifc,iel,1) .eq. 'sh ') .or. 
     $               (cbc(ifc,iel,1) .eq. 'W  ') .or.
     $               (cbc(ifc,iel,1) .eq. 'V  ')).AND.
     $               (ym1(1,1,1,iel).lt.0)) then
              flag(iel) = -1
              bot_y = ym1(1,ly1,1,iel)
           endif
         enddo
      enddo

      top_y = glmax(top_y,1)
      bot_y = glmin(bot_y,1)

      ! Flag elements neighboring near wall to for continuity enforcement
      ! that isn't used
      do iel=1,nelv
        if (ym1(1,ly1,1,iel) .eq. top_y) then
          flag(iel) = 2
        else if (ym1(1,1,1,iel) .eq. bot_y) then
          flag(iel) = -2
        endif
      enddo

      do iel=1,nelv
        if (flag(iel) .eq. 1) then
          counterp = counterp+1
        else if (flag(iel) .eq. -1) then
          countern = countern+1
        else if (flag(iel) .eq. 2) then
          counterp2 = counterp2 + 1
        else if (flag(iel) .eq. -2) then
          countern2 = countern2 +1
        endif
      enddo

      counterp = iglsum(counterp,1)
      countern = iglsum(countern,1)

      counterp2 = iglsum(counterp2,1)
      countern2 = iglsum(countern2,1)

      if (nid.eq.0) then 
          write(6,*) '# Boundary Elements Above Centerline:', counterp
          write(6,*) '# Boundary Elements Below Centerline:', countern
          write(6,*) '# 2Boundary Elements Above Centerline:', counterp2
          write(6,*) '# 2Boundary Elements Below Centerline:', countern2
          write(6,*) 'yen top:', top_y
          write(6,*) 'yen bot:', bot_y
      endif

      param(54) = -1  ! use >0 for const flowrate or <0 bulk vel
                      ! flow direction is given by (1=x, 2=y, 3=z) 
      param(55) = 1.0 ! flowrate/bulk-velocity   

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3 ()
      implicit none
      include 'SIZE'
      include 'TOTAL'

      real wd
      common /walldist/ wd(lx1,ly1,lz1,lelv)

      integer ifld_k,ifld_omg,m_id,w_id
      real coeffs(21) !array for passing your own coeffs
      logical ifcoeffs
      integer n

      n=nx1*ny1*nz1*nelv
c     calculate wall distance for regularized k-omega
      call rone(wd,n)
      call abssub2(wd,ym1,n)
      

      ifld_k = 3 !address of tke equation in t array
      ifld_omg = 4 !address of omega equation in t array
      ifcoeffs=.false. !set to true to pass your own coeffs

C     Supported models:
c     m_id = 0 !regularized high-Re k-omega (no wall functions)
      m_id = 1 !regularized low-Re k-omega
c     m_id = 2 !regularized high-Re k-omega SST (no wall functions)
c     m_id = 3 !regularized low-Re k-omega SST

C     Wall distance function:
      w_id = 0 ! user specified
c     w_id = 1 ! cheap_dist (path to wall, may work better for periodic boundaries)
c     w_id = 2 ! distf (coordinate difference, provides smoother function)

      call rans_komg_init(ifld_k,ifld_omg,ifcoeffs,coeffs,w_id,wd,m_id)

      return
      end
c-----------------------------------------------------------------------
c     WALL FUNCTIONS DEFINED HERE 
      real function f(x,flag,up,yp,rho,mu)
      real x,up,yp,rho,mu   !yp,up,rho,and mu are the location,velocity
                            !,density and dyn.viscosity for the matching 
                            !point; x is the unknown (utau at the wall)
      integer flag
      real lotw

      f = up - lotw (yp,x,mu/rho)

      return
      end
c----------------------------------------------------------------------
c     WALL FUNCTION DERIVATIVES DEFINED HERE (used in N-R solver)
      real function fprime(x,flag,up,yp,rho,mu)
      real x,up,yp,rho,mu   !yp,up,rho,and mu are the location,velocity
                            !,density and dyn.viscosity for the matching
                            !point; x is the unknown (utau at the wall)
      integer flag
      real dlotwdy

      fprime = up - dlotwdy(yp,x,mu/rho)

      return
      end
c----------------------------------------------------------------------
c     NEWTON-RAPHSON SOLVER     
      real function newton(flag,up,yp,rho,mu,xi,rtol,maxiter)  
      implicit none
      integer flag,maxiter,i
      real up,yp,rho,mu,xi,rtol,eps,x,fx,fx1,fx2,xnew,fprime,f,fpr,fnew
      real atol 

      eps = 1.0e-14
      atol = 1.0e-14 
      newton = 0.0 ! assigned if the solution does not converge 
      x = xi
      fx = f(x,flag,up,yp,rho,mu)
      do i = 1,max(1,maxiter)
c        fx=f(x,flag,up,yp,rho,mu)
        fx1=f(x-eps,flag,up,yp,rho,mu)
        fx2=f(x+eps,flag,up,yp,rho,mu)
        fpr=(fx2-fx1)/(2*eps) ! calculate numerical derivative
c        fpr=fprime(x,flag,up,yp,rho,mu)!calculate analytical derivative
        xnew=x-fx/fpr
        fnew=f(xnew,flag,up,yp,rho,mu)
        if(abs((xnew-x)/xnew).le.rtol .AND. abs(fnew).le.atol) then
c        if(abs((xnew-x)/xnew).le.rtol) then
c        if(abs(fnew).le.atol) then
          newton=xnew
          exit
        endif
        x=xnew
        fx=fnew
      enddo
      
c      write(6,*) 'i, newton, xnew, f = ', i, newton, xnew,
c     $ f(newton,flag,up,yp,rho,mu)      

      return
      end
c---------------------------------------------------------------------
c     SECANT SOLVER 
      real function secant(flag,up,yp,rho,mu,xi1,xi2,rtol,maxiter)
      implicit none
      integer flag,maxiter,i
      real up,yp,rho,mu,xi1,xi2,rtol,x,fx,xprev,fxprev,xnew,f

      secant = 0.0  ! assigned if the solution does not converge
      x = xi2
      xprev = xi1
      fxprev=f(xprev,flag,up,yp,rho,mu)
      do i = 1,max(1,maxiter)
        fx=f(x,flag,up,yp,rho,mu)
        xnew=x-fx*(xprev-x)/(fxprev-fx)
        if(abs((xnew-x)/xnew).le.rtol) then
          secant=xnew
          exit
        endif
        fxprev=fx
        xprev=x
        x=xnew
      enddo

c      write(6,*) 'i, secant, f = ', i, secant, 
c     $ f(secant,flag,up,yp,rho,mu)

      return
      end
c-----------------------------------------------------------------------
      subroutine get_limits(phi,phimin,phimax,phiave,dphi,phip,rmsphi,n)
      implicit none
      include 'SIZE'
      include 'TOTAL'

      integer i,n,ntot,iglsum
      real phi(1),phip(1),phimin,phimax,phiave,dphi,rmsphi
      real glmin,glmax,glsc2,glsum

      ntot=iglsum(n,1)

      rmsphi=0.0
      dphi=0.0
      if(istep.ge.1) then
        do i=1,n
          dphi=max(dphi,abs(phip(i)-phi(i)))
          rmsphi=rmsphi+(phip(i)-phi(i))**2
        enddo
        rmsphi=glsum(rmsphi,1)
        rmsphi=sqrt(rmsphi/DBLE(ntot))/dt
      endif
      dphi=glmax(dphi,1)
      dphi=dphi/dt

      phimin=glmin(phi,n)
      phimax=glmax(phi,n)
      phiave=glsc2(phi,bm1,n)/volvm1

      return
      end
C-----------------------------------------------------------------------
      subroutine get_limits_nodt(phi,phimin,phimax,phiave)
      implicit none
      include 'SIZE'
      include 'TOTAL'

      integer n
      real phi(1),phimin,phimax,phiave
      real glmin,glmax,glsc2

      n=nx1*ny1*nz1*nelv

      phimin=glmin(phi,n)
      phimax=glmax(phi,n)
      phiave=glsc2(phi,bm1,n)/volvm1

      return
      end
c-----------------------------------------------------------------------
      subroutine y_p_limits(wd,ypmin,ypmax,ypave,utmin,utmax,utave)
      implicit none
      include 'SIZE'
      include 'TOTAL'

C     calculate min, max, and average y_p+ and u_tau values

      integer e,i,i0,i1,j,j0,j1,k,k0,k1,iw,jw,kw,i2,j2
      integer ipt,wpt,estrd,isd,jsd
      real msk(lx1,ly1,lz1,lelv)
      real gradu(lx1*ly1*lz1,3,3),wd(1)
      real tau(3),norm(3),vsca,tauw,utau,rho,mu
      real ypmin,ypmax,yp,ypave,vol,utmin,utmax,utave
      real glmin,glmax,glsum
      logical ifgrad, ifdid

      data ifdid /.false./
      save ifdid, msk

      ypmin=1.0d30
      ypmax=-1.0d30
      ypave=0.0
      utmin=1.0d30
      utmax=-1.0d30
      utave=0.0
      vol=0.0

C     first build the mask
      if(.not.ifdid)then
        ifdid=.true.
        call rone(msk,nx1*ny1*nz1*nelv)
        do e=1,nelv
          do isd=1,2*ndim
            if(cbc(isd,e,1).eq.'W  ') then
              call backpts(i0,i1,j0,j1,k0,k1,isd)
              do k=k0,k1
              do j=j0,j1
              do i=i0,i1
                msk(i,j,k,e)=0.0
              enddo
              enddo
              enddo
            endif
          enddo
          do isd=1,2*ndim
            if(cbc(isd,e,1).eq.'W  ') then
              call facind(i0,i1,j0,j1,k0,k1,lx1,ly1,lz1,isd)
              do k=k0,k1
              do j=j0,j1
              do i=i0,i1
                msk(i,j,k,e)=1.0
              enddo
              enddo
              enddo
            endif
          enddo
        enddo
        call dssum(msk,nx1,ny1,nz1) !for elements with edges but not faces along a wall
      endif

      do e=1,nelv
        ifgrad=.true.
        do isd=1,2*ndim
          if(cbc(isd,e,1).eq.'W  ')then
            estrd=(e-1)*nx1*ny1*nz1
            if(ifgrad)then
              call gradm11(gradu(1,1,1),gradu(1,1,2),gradu(1,1,3),vx,e)
              call gradm11(gradu(1,2,1),gradu(1,2,2),gradu(1,2,3),vy,e)
              if(if3d)
     &         call gradm11(gradu(1,3,1),gradu(1,3,2),gradu(1,3,3),vz,e)
              ifgrad=.false.
            endif
            call backpts(i0,i1,j0,j1,k0,k1,isd)
            do k=k0,k1
            do j=j0,j1
            do i=i0,i1
              if(msk(i,j,k,e).lt.0.5) then
                iw=i
                jw=j
                kw=k
                if    (isd.eq.1) then
                  jw=1
                elseif(isd.eq.2) then
                  iw=nx1
                elseif(isd.eq.3) then
                  jw=ny1
                elseif(isd.eq.4) then
                  iw=1
                elseif(isd.eq.5) then
                  kw=1
                else
                  kw=nx1
                endif
                call getSnormal(norm,iw,jw,kw,isd,e)
                ipt=i +(j -1)*nx1+(k -1)*nx1*ny1
                wpt=iw+(jw-1)*nx1+(kw-1)*nx1*ny1

                mu=vdiff(iw,jw,kw,e,1)
                rho=vtrans(iw,jw,kw,e,1)

                do i2=1,ldim
                tau(i2)=0.0
                  do j2=1,ldim
                    tau(i2)=tau(i2)+
     &                   mu*(gradu(wpt,i2,j2)+gradu(wpt,j2,i2))*norm(j2)
                  enddo
                enddo

                vsca=0.0
                do i2=1,ldim
                  vsca=vsca+tau(i2)*norm(i2)
                enddo

                tauw=0.0
                do i2=1,ldim
                  tauw=tauw+(tau(i2)-vsca*norm(i2))**2
                enddo
                tauw=sqrt(tauw)
                utau=sqrt(tauw/rho)
                yp=wd(ipt+estrd)*utau*rho/mu
                ypmin=min(ypmin,yp)
                ypmax=max(ypmax,yp)
                ypave=ypave+yp*bm1(i,j,k,e)
                utmin=min(utau,utmin)
                utmax=max(utau,utmax)
                utave=utave+utau*bm1(i,j,k,e)
                vol=vol+bm1(i,j,k,e)
              endif
            enddo
            enddo
            enddo
          endif
        enddo
      enddo

      ypmin=glmin(ypmin,1)
      ypmax=glmax(ypmax,1)
      ypave=glsum(ypave,1)
      utmin=glmin(utmin,1)
      utmax=glmax(utmax,1)
      utave=glsum(utave,1)
      vol=glsum(vol,1)
      ypave=ypave/vol
      utave=utave/vol

      return
      end
c-----------------------------------------------------------------------
      subroutine backpts(i0,i1,j0,j1,k0,k1,isd)
      implicit none
      include 'SIZE'

      integer i0,i1,j0,j1,k0,k1,isd

      i0=1
      j0=1
      k0=1
      i1=nx1
      j1=ny1
      k1=nz1
      if(isd.eq.1) then
        j0=2
        j1=2
      elseif(isd.eq.2) then
        i0=nx1-1
        i1=nx1-1
      elseif(isd.eq.3) then
        j0=ny1-1
        j1=ny1-1
      elseif(isd.eq.4) then
        i0=2
        i1=2
      elseif(isd.eq.5) then
        k0=2
        k1=2
      elseif(isd.eq.6) then
        k0=nz1-1
        k1=nz1-1
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine print_limits
      implicit none
      include 'SIZE'
      include 'TOTAL'

      real vol,glsum,glmin,glmax,glsc2
      real tmp(lx1*ly1*lz1*lelv)
      integer i,n1,n2,nt

      real uxmin,uxmax,uxave,uymin,uymax,uyave,uzmin,uzmax,uzave
      real prmin,prmax,prave
      real thmin(ldimt),thmax(ldimt),thave(ldimt)
      real rmsux,rmsuy,rmsuz,rmspr,rmsth(ldimt)
      real dux,duy,duz,dpr,dth(ldimt)
      character*15 tname

      n1=nx1*ny1*nz1*nelv
      n2=nx2*ny2*nz2*nelv
      nt=nx1*ny1*nz1*nelt

      call get_limits(vx,uxmin,uxmax,uxave,dux,vxlag,rmsux,n1)
      call get_limits(vy,uymin,uymax,uyave,duy,vylag,rmsuy,n1)
      if(if3d) call get_limits(vz,uzmin,uzmax,uzave,duz,vzlag,rmsuz,n1)
      call get_limits(pr,prmin,prmax,prave,dpr,prlag,rmspr,n2)
      if(ifheat)then
        do i=1,npscal+1
          if(idpss(i).eq.0) call get_limits(t(1,1,1,1,i),thmin(i) !Helmholtz solver
     &          ,thmax(i),thave(i),dth(i),tlag(1,1,1,1,1,i),rmsth(i),nt)
          if(idpss(i).eq.1) call get_limits_nodt(t(1,1,1,1,i) !CVODE solver
     &                      ,thmin(i),thmax(i),thave(i))
        enddo
      endif

      if(nio.eq.0) then
        write(*,*)
        write(*,254) 'limits','min','max','ave','max d/dt','rms d/dt'
        write(*,255) 'u velocity',uxmin,uxmax,uxave,dux,rmsux
        write(*,255) 'v velocity',uymin,uymax,uyave,duy,rmsuy
        if(if3d) write(*,255) 'w velocity',uzmin,uzmax,uzave,duz,rmsuz
        write(*,255) 'pressure',prmin,prmax,prave,dpr,rmspr
        if(ifheat) then
          do i=1,npscal+1
            if(i.eq.1) write(tname,'(a15)') "temperature"
            if(i.gt.1) write(tname,'(a14,i1)') "PS ",i-1
            if(idpss(i).eq.0)write(*,255)
     &               tname,thmin(i),thmax(i),thave(i),dth(i),rmsth(i)
            if(idpss(i).eq.1)write(*,256)
     &               tname,thmin(i),thmax(i),thave(i),'--','--'
          enddo
        endif
        write(*,*)
      endif

 254  format(a15,5a13)
 255  format(a15,5es13.4)
 256  format(a15,3es13.4,2a13)

      return
      end
c-----------------------------------------------------------------------

c---------------------------------------------------------------------
c     BISECTION SOLVER (not tested)
c      implicit none
c      real function bisection(flag,up,yp,rho,mu,a,b,atol,maxiter)
c      integer flag,maxiter,i
c      real up,yp,rho,mu,a,b,c,atol,fa,fc,f
c
c      bisection = 0.0
c      do i = 1,max(1,maxiter)
c        c=(a+b)/2
c        fc=f(c,flag,up,yp,rho,mu)
c        fa=f(a,flag,up,yp,rho,mu)
c        if((b-a)/2.le.atol .OR. fc.eq.0) then
c          bisection=c
c          exit
c        endif
c      if(fc/abs(fc) .eq. fa/abs(fa)) then
c        a=c
c      else b=c
c      endif 
c      enddo

c      write(6,*) 'i, bisection, f = ', i, bisection, 
c     $ f(bisection,flag,up,yp,rho,mu)

c      return
c      end
c-------------------------------------------------------------------

C c-----------------------------------------------------------------------
C       real function lotw (yw,utau,nu)
C       implicit none
C       real x, y, z, utau, nu ! Wall distance
C       integer flag
C       real Re_tau, ypb, yw, yp
      
C       yp = yw*utau/nu

C       lotw = utau*((1/0.41)*log(1+0.41*yp)+7.8*(1-exp(-yp/(11.0))-
C      $      yp/(11)*exp(-yp/3.)))


C       return
C       end

C c-----------------------------------------------------------------------
C       real function dlotwdy (yw,utau,nu)
C       implicit none
C       real x, y, z, utau, nu 
C       integer flag
C       real Re_tau, ypb, yw, yp
C       integer sign

C       Re_tau = utau/nu
C       yp = yw*utau/nu

C       dlotwdy = Re_tau*utau*((1/0.41)*(0.41)/(1+0.41*yp)
C      $   +7.8*(1.0/11.0*exp(-yp/(11.0))+
C      $      (yp-3.0)/(33)*exp(-yp/3.)))


C       return
C       end