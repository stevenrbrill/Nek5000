c- constants -----------------------------------------------------------

c data extraction along wall normal direction
#define INTP_NMAX 200 /* number of sample points */
#define MYZCINT 1.0     /* z coordinate of 1D line */

c mesh dimensions
#define NUMBER_ELEMENTS_X 22
#define NUMBER_ELEMENTS_Y 11
#define NUMBER_ELEMENTS_Z 11

c MA
#define LPTS 10000
#define deltaw 0.14285714285 /*Matching location*/

C-----------------------------------------------------------------------
c
c     user subroutines required by nek5000
c
c-----------------------------------------------------------------------
      subroutine srbprint (u)
      ! Print the solution 
      include 'SIZE'
      include 'TOTAL'

      real u(lx1, ly1, lz1, nelv)

      do iel = 1, nelv
        do ix = 1,lx1
          do iy = 1,ly1
            do iz = 1,lz1
                  print *, iel, ix, iy, iz, u(ix,iy,iz,iel)
            enddo
          enddo
        enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ieg)
      include 'SIZE'
      include 'NEKUSE'          ! UDIFF, UTRANS

      UDIFF =0.
      UTRANS=0.

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'NEKUSE'          ! FF[XYZ]

      FFX = 0.0
      FFY = 0.0
      FFZ = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'NEKUSE'          ! QVOL

      QVOL   = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'

c     Point for torque calculation
      real x0(3)
      data x0 /3*0.0/   

      integer icalld
      save    icalld
      data    icalld /0/

      real atime,timel
      save atime,timel

      integer ntdump
      save    ntdump

      real    rwk(INTP_NMAX,ldim+1) ! r, s, t, dist2
      integer iwk(INTP_NMAX,3)      ! code, proc, el 
      save    rwk, iwk

      integer nint, intp_h
      save    nint, intp_h

      logical iffpts
      save iffpts

      real xint(INTP_NMAX),yint(INTP_NMAX),zint(INTP_NMAX)
      save xint, yint, zint
      save igs_x, igs_z

      parameter(nstat=9)
      real ravg(lx1*ly1*lz1*lelt,nstat)
      real stat(lx1*ly1*lz1*lelt,nstat)
      real stat_y(INTP_NMAX*nstat)
      save ravg, stat, stat_y

      save dragx_avg
      save dragz_avg

      logical ifverbose
      common /gaaa/    wo1(lx1,ly1,lz1,lelv)
     &              ,  wo2(lx1,ly1,lz1,lelv)
     &              ,  wo3(lx1,ly1,lz1,lelv)

      integer flag(lelv)
      common /beflag/ flag

c----------------------------------------------------------------
c     VARIABLES DECLARED FOR USING THE NON-ITERATIVE METHOD  
      real tauold(lx1,ly1,lz1,lelv), taunewx(lx1,ly1,lz1,lelv)
      real taunewy(lx1,ly1,lz1,lelv), taunewz(lx1,ly1,lz1,lelv)
      common /wallshear/ taunewx,taunewy,taunewz
      save tauold
      
      real M, Kappa, utau_init
      data M/5.17/, kappa/0.41/, utau_init/0.2/
      save M, kappa, utau_init
c----------------------------------------------------------------
c     VARIABLES DECLARED FOR USING THE ITERATIVE METHOD 
      real newton,secant,rtol,ut0,ut1,uti(lx1,ly1,lz1,lelv),utau
      integer flg, maxiter, count
      data rtol/1.0e-5/, maxiter/200/
      data flg/2/, count/0/ !flg = flag for the chosen wall model
c      data uti/0.2/  !Initial guess value of utau for Newton Method
      data ut0/0.04/, ut1/0.08/ !Initial guess values for Secant Method
      save rtol, maxiter, flg, uti, ut0, ut1
c---------------------------------------------------------------
c     VARIABLES DECLARED FOR GENERAL WALL !MA
      character*3 cb
      integer npts
      real xmp,ymp,zmp
      real x1(ldim,LPTS),u1(ldim,LPTS)
      real*8 unw(ldim,LPTS),t1w(ldim,LPTS),t2w(ldim,LPTS)
      real*8 utt1,utt2,utgt,utgtx,utgty,utgtz,utgtmag
c---------------------------------------------------------------
 

      real tplus
      real tmn, tmx   
      
      integer bIDs(1), iobj_wall(2)
      common /local_obj/ iobj_wall

      n     = nx1*ny1*nz1*nelv
      nelx  = NUMBER_ELEMENTS_X
      nely  = NUMBER_ELEMENTS_Y
      nelz  = NUMBER_ELEMENTS_Z

c MA
      nface = 2*ldim

      if (istep.eq.0) then
         bIDs(1) = 1
         call create_obj(iobj_wall(1),bIDs,1)
         bIDs(1) = 2
         call create_obj(iobj_wall(2),bIDs,1)
      endif    

      ubar = glsc2(vx,bm1,n)/volvm1
      e2   = glsc3(vy,bm1,vy,n)+glsc3(vz,bm1,vz,n)
      e2   = e2/volvm1
      if (nfield.gt.1) then
        tmn  = glmin(t,n)
        tmx  = glmax(t,n)
      endif
      if(nid.eq.0) write(6,2) time,ubar,e2,tmn,tmx
   2               format(1p5e13.4,' monitor')

c     EQUILIBRIUM WALL STRESS MODEL...START

c     Currently all the lines for the non-iterative method are commented
c     For iterative method: up,yp = velocity,location of matching point
c     For non-iterative method: up,yp = uplus,yplus of matching point

      if (istep.eq.0) then
         do iel = 1, nelv
          do ix = 1, lx1
           do iy = 1, ly1
            do iz = 1, lz1
c              tauold(ix,iy,iz,iel) = param(1)*(utau_init)**2
               tauold(ix,iy,iz,iel)=0.0
               uti(ix,iy,iz,iel) = 0.03 ! Guess value for N-R solver
            enddo
           enddo
          enddo
         enddo
      endif

      if (time.le.50.0) then
         do iel = 1, nelv
          do ix = 1, lx1
           do iy = 1, ly1
            do iz = 1, lz1
              taunewx(ix,iy,iz,iel) = 0.0
              taunewy(ix,iy,iz,iel) = 0.0
              taunewz(ix,iy,iz,iel) = 0.0
            enddo
           enddo
          enddo
         enddo

      else
c MA - start
      npts=0
      do iel=1,nelv
        do iface=1,nface
          cb  = cbc (iface,iel,1)
          if(cb.eq.'sh ') then
c Find the gll points on the wall faces
            ia=0
            CALL FACIND (KX1,KX2,KY1,KY2,KZ1,KZ2,NX1,NY1,NZ1,IFACE)
            do iz=kz1,kz2
            do iy=ky1,ky2
            do ix=kx1,kx2
c Find the normal vector at these points
              ia=ia+1
              npts=npts+1
              unw(1,npts)=unx(ia,1,iface,iel)
              unw(2,npts)=uny(ia,1,iface,iel)
              unw(3,npts)=unz(ia,1,iface,iel)
              t1w(1,npts)=t1x(ia,1,iface,iel)
              t1w(2,npts)=t1y(ia,1,iface,iel)
              t1w(3,npts)=t1z(ia,1,iface,iel)
              t2w(1,npts)=t2x(ia,1,iface,iel)
              t2w(2,npts)=t2y(ia,1,iface,iel)
              t2w(3,npts)=t2z(ia,1,iface,iel)
c Find the coordinates at a distance delta along the normal vector
              xmp=xm1(ix,iy,iz,iel)-deltaw*unw(1,npts)
              ymp=ym1(ix,iy,iz,iel)-deltaw*unw(2,npts)
              zmp=zm1(ix,iy,iz,iel)-deltaw*unw(3,npts)
              x1(1,npts)=xmp
              x1(2,npts)=ymp
              x1(3,npts)=zmp
            enddo
            enddo
            enddo
          endif
        enddo
      enddo

c Find the velocity and scalar values at this point
      call interp_v(u1,x1,npts)
      npts=0
      do iel=1,nelv
        do iface=1,nface
          cb  = cbc (iface,iel,1)
          if(cb.eq.'sh ') then
c Find the gll points on the wall faces
            CALL FACIND (KX1,KX2,KY1,KY2,KZ1,KZ2,NX1,NY1,NZ1,IFACE)
            do iz=kz1,kz2
            do iy=ky1,ky2
            do ix=kx1,kx2
              npts=npts+1
              utt1=t1w(1,npts)*u1(1,npts)+t1w(2,npts)*u1(2,npts)+
     $            t1w(3,npts)*u1(3,npts)
              utt2=t2w(1,npts)*u1(1,npts)+t2w(2,npts)*u1(2,npts)+
     $            t2w(3,npts)*u1(3,npts)
              utgt=(utt1**2+utt2**2)**(0.5)
              utgtx=utt1*t1w(1,npts)+utt2*t2w(1,npts)
              utgty=utt1*t1w(2,npts)+utt2*t2w(2,npts)
              utgtz=utt1*t1w(3,npts)+utt2*t2w(3,npts)
              utgtmag=(utgtx**2+utgty**2+utgtz**2)**(0.5)
              utgtx=utgtx/utgtmag
              utgty=utgty/utgtmag
              utgtz=utgtz/utgtmag
              tauold(ix,iy,iz,iel)=utgtz/utgtx

              yp=deltaw
              up=utgt
      utau = newton(flg,up,yp,param(1),param(2),uti(ix,iy,iz,iel),rtol,
     $              maxiter)
c      utau = secant(flg,up,yp,param(1),param(2),ut0,ut1,rtol,maxiter)
      if (utau .eq. 0.0) count = count + 1 ! count unconverged solutions
      if (utau .ne. 0.0) uti(ix,iy,iz,iel) = utau ! update guess value
                                                   ! for next time step
               taunewx(ix,iy,iz,iel) = -param(1)*utau**2*utgtx ! shear stress
c               taunewx(ix,iy,iz,iel) = -param(1)*utau**2 ! shear stress
               taunewy(ix,iy,iz,iel) = -param(1)*utau**2*utgty ! shear stress
               taunewz(ix,iy,iz,iel) = -param(1)*utau**2*utgtz ! shear stress
      if (utau .eq. 0.0) then 
C                taunewx(ix,iy,iz,iel) = 0.0
C                taunewy(ix,iy,iz,iel) = 0.0
C                taunewz(ix,iy,iz,iel) = 0.0
               taunewx(ix,iy,iz,iel) = -param(1)*(uti(ix,iy,iz,iel)**2)
     $                                *utgtx 
               taunewy(ix,iy,iz,iel) = -param(1)*(uti(ix,iy,iz,iel)**2)
     $                                *utgty 
               taunewz(ix,iy,iz,iel) = -param(1)*(uti(ix,iy,iz,iel)**2)
     $                                *utgtz 
      endif
            enddo
            enddo
            enddo
          endif
        enddo
      enddo
c MA - end
c      call outpost(taunewx,taunewy,taunewz,pr,t,'   ')
c      call exitt

      count = iglsum(count,1)

      if(nid.eq.0) then
       write(6,*) 'Solutions not converged: ', count
      endif

      count = 0
      utaumax=glmax(uti,n)
      utaumin=glmin(uti,n)
      if(nid.eq.0) write(6,*) utaumax,utaumin,'utau'      
      tauxmax=glmax(taunewx,n)
      tauxmin=glmin(taunewx,n)
      if(nid.eq.0) write(6,*) tauxmax,tauxmin,'taux'
      tauzmax=glmax(taunewz,n)
      tauzmin=glmin(taunewz,n)
      if(nid.eq.0) write(6,*) tauzmax,tauzmin,'tauz'
      tauzmax=glmax(tauold,n)
      tauzmin=glmin(tauold,n)
      if(nid.eq.0) write(6,*) tauzmax,tauzmin,'tgt z/x'
      endif

c      do iel = 1, nelv
c       do ix = 1, lx1
c        do iy = 1, ly1
c         do iz = 1, lz1
c           tauold(ix,iy,iz,iel) = -taunew(ix,iy,iz,iel)
c         enddo
c        enddo
c       enddo
c      enddo

c     EQUILIBRIUM WALL STRESS MODEL...END   
      
      call torque_calc(1.,x0,.true.,.false.)

      if(ifoutfld) then
        ifto = .true.
        call lambda2(t)
      endif

      if (istep.eq.0) call outpost(vx,vy,vz,pr,t,'   ')
      
      call statistics
      
      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
C       implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'          ! UX, UY, UZ, TEMP, X, Y, PA
      integer ix,iy,iz,iside,ieg, e      
      
      real taunewx(lx1,ly1,lz1,lelv),taunewy(lx1,ly1,lz1,lelv)
      real taunewz(lx1,ly1,lz1,lelv)
      common /wallshear/ taunewx,taunewy,taunewz

      if (y.lt.0) temp = 1.0
      if (y.gt.0) temp = 0.0

      e = gllel(ieg)

c     Imposing shear stress B.C.s
      if(cbc(iside,e,1).eq.'sh ') then
        TRX=taunewx(ix,iy,iz,e)
        TRY=taunewy(ix,iy,iz,e)
        TRZ=taunewz(ix,iy,iz,e)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      implicit none
      include 'SIZE'
      include 'NEKUSE'          ! UX, UY, UZ, TEMP, X, Y, Z
      integer ix,iy,iz,ieg

      real amp, ran
      
      amp = 0.2

      ran = 3.e4*(ieg+X*sin(Y)+Z*cos(Y))
     $     + 4.7e2*ix*iy*iz - 1.5e3*ix*iy + .5e5*ix
      ran = 6.e3*sin(ran)
      ran = 3.e3*sin(ran)
      ran = cos(ran)
      ux = 1. + ran*amp
      
      ran = (2+ran)*1.e4*(ieg+Y*sin(Z)+X*cos(Z))
     $     + 1.5e3*ix*iy*iz - 2.5e3*ix*iy + 8.9e4*ix
      ran = 2.e3*sin(ran)
      ran = 7.e3*sin(ran)
      ran = cos(ran)
      uy = ran*amp
      
      ran = (4+ran)*5.1e4*(ieg+Z*sin(X)+Y*cos(X))
     $     + 4.6e3*ix*iy*iz - 2.9e4*ix*iy + 3.7e3*ix
      ran = 9.e3*sin(ran)
      ran = 4.e3*sin(ran)
      ran = cos(ran)
      uz = ran*amp

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      implicit none
      include 'SIZE'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
C       implicit none
      include 'SIZE'
      include 'TOTAL'
C       include 'SOLN'            ! vx,vy,vz,pr,t
C       include 'GEOM'            ! boundaryID
C       include 'INPUT'           ! cbc
      
      integer iel
      integer flag(lelv), counterp, countern
      common /beflag/ flag
c     mesh stretching
      real Betax, Betay
c     Hill parameters
      real Lx, Ly, Lz, W, H
      common /hill_param/ Lx, Ly, Lz, W, H, Betax, Betay
      
      Betax = 2.0
      Betay = 2.4
      Lx = 9.
      Ly = 3.035
      Lz = 4.5
      W  = 1.929
      H = 1.

c               Lx      
c      <----------------->
c      ___________________ 
c                           ^
c                           |
c                           |
c      _                 _  | Ly
c   ^   \               /   |
c H |    \             /    |
c   v     \___________/     v
c      <-->
c       W
      
c     Transform box mesh to periodic hill (only for the conforming mesh!!)
      call box2phill

c      call gen_re2(0)

c     mark faces for object definition
      do iel=1,nelt
         if (cbc(1,iel,1) .eq. 'W  ') then  ! bottom wall
            boundaryID(1,iel) = 1
         else if (cbc(3,iel,1) .eq. 'W  ') then ! top wall
            boundaryID(3,iel) = 2
         endif 
      enddo

      counterp = 0
      countern = 0
      
      do iel=1,nelt
      do ifc=1,2*ndim
         if (cbc(ifc,iel,1) .eq. 'sh ') boundaryID(ifc,iel) = 1 
         cbc(ifc,iel,2) = cbc(ifc,iel,1) 
         if (cbc(ifc,iel,1) .eq. 'sh ') cbc(ifc,iel,2) = 't  '
      enddo
      enddo

      ! Flag boundary elements above and below centerline (y = 0)
      do iel=1,nelv
         do ifc=1,2*ldim
       if ((cbc(ifc,iel,1).eq.'sh ').AND.(ym1(1,1,1,iel).gt.2.5)) then
              flag(iel) = 1
              counterp = counterp+1
           else if ((cbc(ifc,iel,1).eq.'sh ').AND.
     $             (ym1(1,1,1,iel).lt.2.5)) then
              flag(iel) = -1
              countern = countern+1
           endif
         enddo
      enddo

      counterp = iglsum(counterp,1)
      countern = iglsum(countern,1)

      if (nid.eq.0) then 
          write(6,*) '# Boundary Elements Above Centerline:', counterp
          write(6,*) '# Boundary Elements Below Centerline:', countern
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      implicit none
      include 'SIZE'
      include 'INPUT'           ! param, if3d
      include 'MASS'            ! volvm1      
      
c     Local variables
      real Ubulk
      
      real Betax,Betay
c     Hill parameters
      real Lx, Ly, Lz, W, H
      common /hill_param/ Lx, Ly, Lz, W, H, Betax, Betay

c     apply mass flux to drive the flow such that
c     - Ubulk = velocity averaged over the whole domain
c     - Ubar_inlet = velocity averaged over the inlet plane = 1.
      if (if3d) then
         Ubulk = (Lx*(Ly-H)*Lz)/volvm1
      else
         Ubulk = (Lx*(Ly-H))/volvm1
      endif

      if (nid.eq.0) write(6,*) 'U_bulk = ', Ubulk, ' Ubar_inlet = 1'
      
      param(54) = -1            ! x-direction
      param(55) = Ubulk         ! Ubulk      
      
      return
      end
c-----------------------------------------------------------------------
      subroutine box2phill
      implicit none
      include 'SIZE'
      include 'GEOM'            ! {x,y,z}m1
      include 'INPUT'           ! param
      include 'SOLN'

      integer i, ntot
      real Betax, Betay
      real Lx, Ly, Lz, Wh, H    ! x dimension, y dimension, hill half width, hill height
      common /hill_param/ Lx, Ly, Lz, Wh, H, Betax ,Betay
      real shift, amp
      real xscale, yscale, zscale, yh, xx, yy, zz
      real hill_step,hill_height,xfac,glmax,glmin
      real xmin, xmax, ymin, ymax, zmin, zmax
      save xmin, xmax, ymin, ymax, zmin, zmax
      logical ifminmax
      save ifminmax
      data ifminmax /.false./
      
      ntot = nx1*ny1*nz1*nelt

      if (.not.ifminmax) then
         ifminmax = .true.
         xmin = glmin(xm1,ntot)
         xmax = glmax(xm1,ntot)
         ymin = glmin(ym1,ntot)
         ymax = glmax(ym1,ntot)
         if (if3d) then
            zmin = glmin(zm1,ntot)
            zmax = glmax(zm1,ntot)
         endif
      endif
      
C     decrease resolution in the high velocity regions (increase CFL)
      do i=1,ntot
         xm1(i,1,1,1) = 0.5*(sinh(Betax*(xm1(i,1,1,1)-0.5))/
     $    sinh(Betax*0.5) + 1.0)
      enddo

c     increase resolution near the wall
      do i=1,ntot
         ym1(i,1,1,1) = 0.5*(tanh(Betay*(2*ym1(i,1,1,1)-1.0))/
     $    tanh(Betay) + 1.0)
      enddo
      
c     rescale rectangular domain [0,Lx]x[0,Ly]x[0,Lz]
      xscale = Lx/(xmax-xmin)
      yscale = Ly/(ymax-ymin)
      do i=1,ntot
         xx = xm1(i,1,1,1)
         yy = ym1(i,1,1,1)
         xm1(i,1,1,1) = (xx - xmin) * xscale
         ym1(i,1,1,1) = (yy - ymin) * yscale
      enddo
      if (if3d) then
         zscale = Lz/(zmax-zmin)
         do i=1,ntot
            zz = zm1(i,1,1,1)
            zm1(i,1,1,1) = (zz - zmin) * zscale
         enddo
      endif

c     Shift points in x
      amp = 0.25
      do i=1,ntot
         xx = xm1(i,1,1,1)
         yy = ym1(i,1,1,1)
         xm1(i,1,1,1) = xx + amp*shift(xx,yy,Lx,Ly,Wh)
      enddo
      
c     Add hill
      do i=1,ntot
         xx = xm1(i,1,1,1)
         yy = ym1(i,1,1,1)
         yh = hill_height(xx,Lx,Wh,H)
         yscale = 1-yh/Ly
         ym1(i,1,1,1) = yh + yy * yscale
      enddo

      return
      end
c-----------------------------------------------------------------------
C     Step function for the hill
C
C          x=0
C           | 
C      _____|  
C   ^       \
C   |        \     x->
C h |         \
C   v          \_____
C           <-->
C            w     
      function hill_step(x,w,h)
      implicit none

      real x,xs,w,h
      real y,hill_step

      xs = x/w

      if (xs.le.0) then
         y = h
      elseif (xs.gt.0.and.xs.le.9./54.) then
         y = h*min(1.,1.+7.05575248e-1*xs**2-1.1947737203e1*xs**3)
      elseif (xs.gt.9./54.and.xs.le.14./54.) then
         y = h*(0.895484248+1.881283544*xs-10.582126017*xs**2
     $        +10.627665327*xs**3)
      elseif (xs.gt.14./54.and.xs.le.20./54.) then
         y = h*(0.92128609+1.582719366*xs-9.430521329*xs**2
     $        +9.147030728*xs**3)
      elseif (xs.gt.20./54..and.xs.le.30./54.) then
         y = h*(1.445155365-2.660621763*xs+2.026499719*xs**2
     $        -1.164288215*xs**3)
      elseif (xs.gt.30./54..and.xs.le.40./54.) then
         y = h*(0.640164762+1.6863274926*xs-5.798008941*xs**2
     $        +3.530416981*xs**3)
      elseif (xs.gt.40./54..and.xs.le.1.) then
         y = h*(2.013932568-3.877432121*xs+1.713066537*xs**2
     $        +0.150433015*xs**3)
      else
         y = 0.
      endif

      hill_step = y
      
      return
      end
c----------------------------------------------------------------------- 
      function hill_height(x,Lx,w,H)
      implicit none
      real hill_height,hill_step,x,Lx,w,h
      real xx

      if (x.lt.0) then
         xx = Lx + mod(x, Lx)
      elseif (x.gt.Lx) then
         xx = mod(x, Lx)
      else
         xx = x
      endif

      hill_height = hill_step(xx,w,h) + hill_step(Lx-xx,w,h)
      
      return
      end          
c-----------------------------------------------------------------------      
      function shift(x,y,Lx,Ly,W)
      implicit none
      real x,y,Lx,Ly,W
      real xfac,yfac,shift

      yfac = (1-y/Ly)**3

      if (x.le.W/2) then
         xfac = -2./W * x
      elseif (x.gt.W/2.and.x.le.Lx-W/2) then
         xfac = 2./(Lx-W) * x -1-W/(Lx-W)
      elseif (x.gt.Lx-W/2) then
         xfac = -2./W * x + 2*Lx/W
      endif

      shift = xfac*yfac

      return
      end
c-----------------------------------------------------------------------
      subroutine statistics

c
c     What follows computes some statistics ...
c
      include 'SIZE'
      include 'TOTAL'

c     parameters for line definition
      integer intp_nmax, nelx, nely, nelz
      parameter (intp_nmax=INTP_NMAX, nelx=NUMBER_ELEMENTS_X,
     $   nely=NUMBER_ELEMENTS_Y, nelz=NUMBER_ELEMENTS_Z)
      real xcint, zcint, ylen, betam
      parameter (xcint=4.0, zcint=MYZCINT, ylen=3.035, betam=2.4)
      real xcint1, xcint2, xcint3, xcint4, xcint5, xcint6, xcint7,
     $     xcint8, xcint9, xcint10
      parameter (xcint1=0.05,xcint2=0.5,xcint3=1.,xcint4=2.,xcint5=3.)
      parameter (xcint6=4.,xcint7=5.,xcint8=6.,xcint9=7.,xcint10=8.)

c     statistics start time and output frequency
      real tstatstar, tstatfreq

c     object definition
      real a_tmp(maxobj), wa(maxobj), A_w
      save A_w

      real x0(3)
      data x0 /0.0, 0.0, 0.0/ 
      save x0

      integer icalld
      save    icalld
      data    icalld /0/

      real atime,timel
      save atime,timel

      integer ntdump
      save    ntdump
      
      real    rwk(intp_nmax,ldim+1) ! r, s, t, dist2
      integer iwk(intp_nmax,3)      ! code, proc, el 
      save    rwk, iwk

      integer nint, intp_h
      save    nint, intp_h
      integer intp_h1, intp_h2, intp_h3, intp_h4, intp_h5, intp_h6,
     $        intp_h7, intp_h8, intp_h9, intp_h10
      save    intp_h1, intp_h2, intp_h3, intp_h4, intp_h5, intp_h6,
     $        intp_h7, intp_h8, intp_h9, intp_h10 

      logical iffpts
      save iffpts

      real xint(intp_nmax),yint(intp_nmax),zint(intp_nmax)
      save xint, yint, zint
      save igs_z


      real    rwk1(intp_nmax,ldim+1), rwk2(intp_nmax,ldim+1),
     $        rwk3(intp_nmax,ldim+1), rwk4(intp_nmax,ldim+1),
     $        rwk5(intp_nmax,ldim+1), rwk6(intp_nmax,ldim+1),
     $        rwk7(intp_nmax,ldim+1), rwk8(intp_nmax,ldim+1),
     $        rwk9(intp_nmax,ldim+1), rwk10(intp_nmax,ldim+1)
      integer iwk1(intp_nmax,3), iwk2(intp_nmax,3), iwk3(intp_nmax,3),
     $        iwk4(intp_nmax,3), iwk5(intp_nmax,3), iwk6(intp_nmax,3),
     $        iwk7(intp_nmax,3), iwk8(intp_nmax,3), iwk9(intp_nmax,3),
     $        iwk10(intp_nmax,3)
      save    rwk1, iwk1, rwk2, iwk2, rwk3, iwk3, rwk4, iwk4,
     $        rwk5, iwk5, rwk6, iwk6, rwk7, iwk7, rwk8, iwk8,
     $        rwk9, iwk9, rwk10, iwk10 

      real xint1(intp_nmax),xint2(intp_nmax),xint3(intp_nmax),
     $     xint4(intp_nmax),xint5(intp_nmax),xint6(intp_nmax),
     $     xint7(intp_nmax),xint8(intp_nmax),xint9(intp_nmax),
     $     xint10(intp_nmax) 
      save xint1, xint2, xint3, xint4, xint5, xint6, xint7, xint8, 
     $     xint9, xint10

      real ycint1, ycint2, ycint3, ycint4, ycint5, ycint6, ycint7,
     $     ycint8, ycint9, ycint10
      real yint1(intp_nmax),yint2(intp_nmax),yint3(intp_nmax),
     $     yint4(intp_nmax),yint5(intp_nmax),yint6(intp_nmax),
     $     yint7(intp_nmax),yint8(intp_nmax),yint9(intp_nmax),
     $     yint10(intp_nmax) 
      save yint1, yint2, yint3, yint4, yint5, yint6, yint7, yint8, 
     $     yint9, yint10

      real  zint1(intp_nmax),zint2(intp_nmax),zint3(intp_nmax),
     $     zint4(intp_nmax),zint5(intp_nmax),zint6(intp_nmax),
     $     zint7(intp_nmax),zint8(intp_nmax),zint9(intp_nmax),
     $     zint10(intp_nmax) 
      save zint1, zint2, zint3, zint4, zint5, zint6, zint7, zint8, 
     $     zint9, zint10

      parameter(nstat=8)
      real ravg(lx1*ly1*lz1*lelt,nstat)
      real stat(lx1*ly1*lz1*lelt,nstat)
      real stat_y(intp_nmax*nstat)
      save ravg, stat, stat_y

      real stat_y1(intp_nmax*nstat)
      real stat_y2(intp_nmax*nstat)
      real stat_y3(intp_nmax*nstat)
      real stat_y4(intp_nmax*nstat)
      real stat_y5(intp_nmax*nstat)
      real stat_y6(intp_nmax*nstat)
      real stat_y7(intp_nmax*nstat)
      real stat_y8(intp_nmax*nstat)
      real stat_y9(intp_nmax*nstat)
      real stat_y10(intp_nmax*nstat)
      save stat_y1, stat_y2, stat_y3, stat_y4, stat_y5, stat_y6, 
     $     stay_y7, stat_y8, stat_y9, stat_y10 

      real Betax, Betay
      real Lx, Ly, Lz, Wh, H    ! x dimension, y dimension, hill half width, hill height
      common /hill_param/ Lx, Ly, Lz, Wh, H, Betax ,Betay
      real hill_height

      save dragx_avg

      logical ifverbose
      common /gaaa/    wo1(lx1,ly1,lz1,lelv)
     &              ,  wo2(lx1,ly1,lz1,lelv)
     &              ,  wo3(lx1,ly1,lz1,lelv)

      real tmn, tmx

      integer bIDs(1)
      save iobj_wall

      common /mycf/ cf(lx1,lelt),cf_top(lx1,lelt),
     $              cp(lx1,lelt),cp_top(lx1,lelt),xf(lx1,lelt)

      tstatstar = uparam(1)
      tstatfreq = uparam(2)
      
      if (time.lt.tstatstar) return

      n     = nx1*ny1*nz1*nelv

      if(icalld.eq.0) then
        if(nid.eq.0) write(6,*) 'Start collecting statistics ...'

        call interp_setup(intp_h,0.0,0,nelv)
        call interp_setup(intp_h1,0.0,0,nelv)
        call interp_setup(intp_h2,0.0,0,nelv)
        call interp_setup(intp_h3,0.0,0,nelv)
        call interp_setup(intp_h4,0.0,0,nelv)
        call interp_setup(intp_h5,0.0,0,nelv)
        call interp_setup(intp_h6,0.0,0,nelv)
        call interp_setup(intp_h7,0.0,0,nelv)
        call interp_setup(intp_h8,0.0,0,nelv)
        call interp_setup(intp_h9,0.0,0,nelv)
        call interp_setup(intp_h10,0.0,0,nelv)

        nint = 0
        if (nid.eq.0) then
          nint = intp_nmax
          call cfill(xint,xcint,size(xint))
          call cfill(xint1,xcint1,size(xint1))
          call cfill(xint2,xcint2,size(xint2))
          call cfill(xint3,xcint3,size(xint3))
          call cfill(xint4,xcint4,size(xint4))
          call cfill(xint5,xcint5,size(xint5))
          call cfill(xint6,xcint6,size(xint6))
          call cfill(xint7,xcint7,size(xint7))
          call cfill(xint8,xcint8,size(xint8))
          call cfill(xint9,xcint9,size(xint9))
          call cfill(xint10,xcint10,size(xint10))

          ycint1 = hill_height(xcint1,Lx,Wh,H)
          ycint2 = hill_height(xcint2,Lx,Wh,H)
          ycint3 = hill_height(xcint3,Lx,Wh,H)
          ycint4 = hill_height(xcint4,Lx,Wh,H)
          ycint5 = hill_height(xcint5,Lx,Wh,H)
          ycint6 = hill_height(xcint6,Lx,Wh,H)
          ycint7 = hill_height(xcint7,Lx,Wh,H)
          ycint8 = hill_height(xcint8,Lx,Wh,H)
          ycint9 = hill_height(xcint9,Lx,Wh,H)
          ycint10 = hill_height(xcint10,Lx,Wh,H)
          do i = 1,intp_nmax 
             yi = (i-1.)/(intp_nmax-1)
             yint(i) = ylen*0.5*(tanh(betam*(2*yi-1.0))/
     $                 tanh(betam)+1.0)
             yint1(i) = (ylen-ycint1)*0.5*(tanh(betam*(2*yi-1.0))/
     $                 tanh(betam)+1.0)+ycint1
             yint2(i) = (ylen-ycint2)*0.5*(tanh(betam*(2*yi-1.0))/
     $                 tanh(betam)+1.0)+ycint2
             yint3(i) = (ylen-ycint3)*0.5*(tanh(betam*(2*yi-1.0))/
     $                 tanh(betam)+1.0)+ycint3
             yint4(i) = (ylen-ycint4)*0.5*(tanh(betam*(2*yi-1.0))/
     $                 tanh(betam)+1.0)+ycint4
             yint5(i) = (ylen-ycint5)*0.5*(tanh(betam*(2*yi-1.0))/
     $                 tanh(betam)+1.0)+ycint5
             yint6(i) = (ylen-ycint6)*0.5*(tanh(betam*(2*yi-1.0))/
     $                 tanh(betam)+1.0)+ycint6
             yint7(i) = (ylen-ycint7)*0.5*(tanh(betam*(2*yi-1.0))/
     $                 tanh(betam)+1.0)+ycint7
             yint8(i) = (ylen-ycint8)*0.5*(tanh(betam*(2*yi-1.0))/
     $                 tanh(betam)+1.0)+ycint8
             yint9(i) = (ylen-ycint9)*0.5*(tanh(betam*(2*yi-1.0))/
     $                 tanh(betam)+1.0)+ycint9
             yint10(i) = (ylen-ycint10)*0.5*(tanh(betam*(2*yi-1.0))/
     $                 tanh(betam)+1.0)+ycint10
          enddo
          yint(1) = yint(1) + 1e-3
          yint1(1) = yint1(1) + 1e-3
          yint2(1) = yint2(1) + 1e-3
          yint3(1) = yint3(1) + 1e-3
          yint4(1) = yint4(1) + 1e-3
          yint5(1) = yint5(1) + 1e-3
          yint6(1) = yint6(1) + 1e-3
          yint7(1) = yint7(1) + 1e-3
          yint8(1) = yint8(1) + 1e-3
          yint9(1) = yint9(1) + 1e-3
          yint10(1) = yint10(1) + 1e-3

          call cfill(zint,zcint,size(zint))
          call cfill(zint1,zcint,size(zint1))
          call cfill(zint2,zcint,size(zint2))
          call cfill(zint3,zcint,size(zint3))
          call cfill(zint4,zcint,size(zint4))
          call cfill(zint5,zcint,size(zint5))
          call cfill(zint6,zcint,size(zint6))
          call cfill(zint7,zcint,size(zint7))
          call cfill(zint8,zcint,size(zint8))
          call cfill(zint9,zcint,size(zint9))
          call cfill(zint10,zcint,size(zint10))
        endif
        iffpts = .true. ! dummy call to find points
        call interp_nfld(stat_y,ravg,1,xint,yint,zint,nint,
     $                   iwk,rwk,intp_nmax,iffpts,intp_h)
        call interp_nfld(stat_y1,ravg,1,xint1,yint1,zint1,nint,
     $                   iwk1,rwk1,intp_nmax,iffpts,intp_h1)
        call interp_nfld(stat_y2,ravg,1,xint2,yint2,zint2,nint,
     $                   iwk2,rwk2,intp_nmax,iffpts,intp_h2)
        call interp_nfld(stat_y3,ravg,1,xint3,yint3,zint3,nint,
     $                   iwk3,rwk3,intp_nmax,iffpts,intp_h3)
        call interp_nfld(stat_y4,ravg,1,xint4,yint4,zint4,nint,
     $                   iwk4,rwk4,intp_nmax,iffpts,intp_h4)
        call interp_nfld(stat_y5,ravg,1,xint5,yint5,zint5,nint,
     $                   iwk5,rwk5,intp_nmax,iffpts,intp_h5)
        call interp_nfld(stat_y6,ravg,1,xint6,yint6,zint6,nint,
     $                   iwk6,rwk6,intp_nmax,iffpts,intp_h6)
        call interp_nfld(stat_y7,ravg,1,xint7,yint7,zint7,nint,
     $                   iwk7,rwk7,intp_nmax,iffpts,intp_h7)
        call interp_nfld(stat_y8,ravg,1,xint8,yint8,zint8,nint,
     $                   iwk8,rwk8,intp_nmax,iffpts,intp_h8)
        call interp_nfld(stat_y9,ravg,1,xint9,yint9,zint9,nint,
     $                   iwk9,rwk9,intp_nmax,iffpts,intp_h9)
        call interp_nfld(stat_y10,ravg,1,xint10,yint10,zint10,nint,
     $                   iwk10,rwk10,intp_nmax,iffpts,intp_h10)
        iffpts = .false.
        call gtpp_gs_setup(igs_z,nelx*nely,1   ,nelz,3) ! z-avg

        call rzero(ravg,size(ravg))
        dragx_avg = 0
        atime     = 0
        timel     = time
        ntdump    = int(time/tstatfreq)

c     get objects surface area     
        nn = nx1*nz1
        do iobj = 1,nobj
           a_tmp(iobj)= 0.0
           do imem = 1, nmember(iobj)
              ieg   = object(iobj,imem,1)
              ifc   = object(iobj,imem,2)
              if (gllnid(ieg).eq.nid) then ! this processor has a contribution
                 iel = gllel(ieg)
                 a_tmp(iobj)=a_tmp(iobj)+vlsum(area(1,1,ifc,iel),nn)
              endif
           enddo
        enddo
        call gop(a_tmp, wa, '+  ', maxobj)
        A_w = 0.0
        do iobj = 1,nobj
           A_w = A_w + a_tmp(iobj)
        enddo

        icalld = 1
      endif

      dtime = time - timel
      atime = atime + dtime

      ! averaging over time
      if (atime.ne.0. .and. dtime.ne.0.) then
        beta      = dtime / atime
        alpha     = 1. - beta

        ifverbose = .false.
        call avg1(ravg(1,1),vx   ,alpha,beta,n,'uavg',ifverbose)
        call avg1(ravg(1,2),vy   ,alpha,beta,n,'vavg',ifverbose)
        call avg1(ravg(1,3),vz   ,alpha,beta,n,'wavg',ifverbose)
        call avg2(ravg(1,4),vx   ,alpha,beta,n,'urms',ifverbose)
        call avg2(ravg(1,5),vy   ,alpha,beta,n,'vrms',ifverbose)
        call avg2(ravg(1,6),vz   ,alpha,beta,n,'wrms',ifverbose)
        call avg3(ravg(1,7),vx,vy,alpha,beta,n,'uvmm',ifverbose)
        call avg1(ravg(1,8),pr   ,alpha,beta,n,'pr',ifverbose)

        call torque_calc(1.0,x0,.false.,.false.) ! compute wall shear
        dragx_avg = alpha*dragx_avg + beta*dragx(0) ! drag from all objects
      endif

      timel = time

      ! write statistics to file
      if(istep.gt.0 .and. time.gt.(ntdump+1)*tstatfreq) then
         ! averaging over statistical homogeneous directions (z)
         do i = 1,nstat
            call planar_avg(stat(1,i),ravg(1,i),igs_z)
         enddo

         ! extract data along wall normal direction (1D profile)
         call interp_nfld(stat_y,stat,nstat,xint,yint,zint,nint,
     $                    iwk,rwk,intp_nmax,iffpts,intp_h)
         call interp_nfld(stat_y1,stat,nstat,xint1,yint1,zint1,nint,
     $                    iwk1,rwk1,intp_nmax,iffpts,intp_h1)
         call interp_nfld(stat_y2,stat,nstat,xint2,yint2,zint2,nint,
     $                    iwk2,rwk2,intp_nmax,iffpts,intp_h2)
         call interp_nfld(stat_y3,stat,nstat,xint3,yint3,zint3,nint,
     $                    iwk3,rwk3,intp_nmax,iffpts,intp_h3)
         call interp_nfld(stat_y4,stat,nstat,xint4,yint4,zint4,nint,
     $                    iwk4,rwk4,intp_nmax,iffpts,intp_h4)
         call interp_nfld(stat_y5,stat,nstat,xint5,yint5,zint5,nint,
     $                    iwk5,rwk5,intp_nmax,iffpts,intp_h5)
         call interp_nfld(stat_y6,stat,nstat,xint6,yint6,zint6,nint,
     $                    iwk6,rwk6,intp_nmax,iffpts,intp_h6)
         call interp_nfld(stat_y7,stat,nstat,xint7,yint7,zint7,nint,
     $                    iwk7,rwk7,intp_nmax,iffpts,intp_h7)
         call interp_nfld(stat_y8,stat,nstat,xint8,yint8,zint8,nint,
     $                    iwk8,rwk8,intp_nmax,iffpts,intp_h8)
         call interp_nfld(stat_y9,stat,nstat,xint9,yint9,zint9,nint,
     $                    iwk9,rwk9,intp_nmax,iffpts,intp_h9)
         call interp_nfld(stat_y10,stat,nstat,xint10,yint10,zint10,nint,
     $                    iwk10,rwk10,intp_nmax,iffpts,intp_h10)

         ntdump = ntdump + 1

         call shear_stress(cf,cf_top,cp,cp_top,xf,
     $       ravg(1,1),ravg(1,2),ravg(1,3),ravg(1,8))
         if (nid.ne.0) goto 998 

         open(unit=55,file='wall_vals.dat')
         npts = lx1*nelx
         write(55,*) " % time   x   cf   cf_top  cp   cp_top"
         write(55,2) (time,xf(k,1),cf(k,1),cf_top(k,1),
     $       cp(k,1),cp_top(k,1),k=1,npts)
   2     format(1p6e14.5)
         close(55)

         rho    = param(1)
         dnu    = param(2)
         tw     = dragx_avg / A_w
         u_tau  = sqrt(tw / rho)
         ! SRB - Local u_taus?????
         Re_tau = u_tau / dnu

         write(6,*) 'Dumping statistics ...', Re_tau
 
         open(unit=56,file='vel_fluc_prof.dat')
         write(56,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', 0.0
         write(56,'(A)') 
     $    '%  y    y+    uu    vv    ww    uv    u_tau   '

         open(unit=57,file='mean_prof.dat')
         write(57,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', ut_param, 
     $     '%u_tau_poly = ', u_tau_poly, '%u_tau_tot = ', u_tau_tot,
     $     '%ut_avg_fit_top  = ', ut_avg_fit_top,  
     $     '%ut_avg_fit_bot  = ', ut_avg_fit_bot,
     $     '%tau_poly = ', tw_poly, '%tau_en = ', tau_param, 
     $     '%tau_tot = ', tw_tot
         write(57,'(A)') 
     $'%  y    y+    Umean    Psimean  Upolymean    Psi   u_tau   Ucomb'


         open(unit=81,file='comp_prof1.dat')
         write(81,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', 0.0,
     $     '%u_tau_poly = ', u_tau_poly, '%u_tau_tot = ', u_tau_tot,
     $     '%ut_avg_fit_top  = ', ut_avg_fit_top,  
     $     '%ut_avg_fit_bot  = ', ut_avg_fit_bot,
     $     '%tau_poly = ', tw_poly, '%tau_en = ', tau_param, 
     $     '%tau_tot = ', tw_tot
         write(81,'(A,A)') 
     $'%  y    Umean    Vmean    Wmean    uu    vv    ww    uv    TKE',
     $'   Psimean  Upolymean    Psi   u_tau   Ucomb' 
         open(unit=82,file='comp_prof2.dat')
         write(82,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', 0.0,
     $     '%u_tau_poly = ', u_tau_poly, '%u_tau_tot = ', u_tau_tot,
     $     '%ut_avg_fit_top  = ', ut_avg_fit_top,  
     $     '%ut_avg_fit_bot  = ', ut_avg_fit_bot,
     $     '%tau_poly = ', tw_poly, '%tau_en = ', tau_param, 
     $     '%tau_tot = ', tw_tot
         write(82,'(A,A)') 
     $'%  y    Umean    Vmean    Wmean    uu    vv    ww    uv    ',
     $'Psimean  Upolymean    Psi   u_tau   Ucomb' 

         open(unit=83,file='comp_prof3.dat')
         write(83,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', 0.0,
     $     '%u_tau_poly = ', u_tau_poly, '%u_tau_tot = ', u_tau_tot,
     $     '%ut_avg_fit_top  = ', ut_avg_fit_top,  
     $     '%ut_avg_fit_bot  = ', ut_avg_fit_bot,
     $     '%tau_poly = ', tw_poly, '%tau_en = ', tau_param, 
     $     '%tau_tot = ', tw_tot
         write(83,'(A,A)') 
     $'%  y    Umean    Vmean    Wmean    uu    vv    ww    uv    TKE',
     $'   Psimean  Upolymean    Psi   u_tau   Ucomb'  

         open(unit=84,file='comp_prof4.dat')
         write(84,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', 0.0,
     $     '%u_tau_poly = ', u_tau_poly, '%u_tau_tot = ', u_tau_tot,
     $     '%ut_avg_fit_top  = ', ut_avg_fit_top,  
     $     '%ut_avg_fit_bot  = ', ut_avg_fit_bot,
     $     '%tau_poly = ', tw_poly, '%tau_en = ', tau_param, 
     $     '%tau_tot = ', tw_tot
         write(84,'(A,A)') 
     $'%  y    Umean    Vmean    Wmean    uu    vv    ww    uv    TKE',
     $'   Psimean  Upolymean    Psi   u_tau   Ucomb'  

         open(unit=85,file='comp_prof5.dat')
         write(85,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', 0.0,
     $     '%u_tau_poly = ', u_tau_poly, '%u_tau_tot = ', u_tau_tot,
     $     '%ut_avg_fit_top  = ', ut_avg_fit_top,  
     $     '%ut_avg_fit_bot  = ', ut_avg_fit_bot,
     $     '%tau_poly = ', tw_poly, '%tau_en = ', tau_param, 
     $     '%tau_tot = ', tw_tot
         write(85,'(A,A)') 
     $'%  y    Umean    Vmean    Wmean    uu    vv    ww    uv    TKE',
     $'   Psimean  Upolymean    Psi   u_tau   Ucomb'  

         open(unit=86,file='comp_prof6.dat')
         write(86,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', 0.0,
     $     '%u_tau_poly = ', u_tau_poly, '%u_tau_tot = ', u_tau_tot,
     $     '%ut_avg_fit_top  = ', ut_avg_fit_top,  
     $     '%ut_avg_fit_bot  = ', ut_avg_fit_bot,
     $     '%tau_poly = ', tw_poly, '%tau_en = ', tau_param, 
     $     '%tau_tot = ', tw_tot
         write(86,'(A,A)') 
     $'%  y    Umean    Vmean    Wmean    uu    vv    ww    uv    TKE',
     $'   Psimean  Upolymean    Psi   u_tau   Ucomb'  

         open(unit=87,file='comp_prof7.dat')
         write(87,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', 0.0,
     $     '%u_tau_poly = ', u_tau_poly, '%u_tau_tot = ', u_tau_tot,
     $     '%ut_avg_fit_top  = ', ut_avg_fit_top,  
     $     '%ut_avg_fit_bot  = ', ut_avg_fit_bot,
     $     '%tau_poly = ', tw_poly, '%tau_en = ', tau_param, 
     $     '%tau_tot = ', tw_tot
         write(87,'(A,A)') 
     $'%  y    Umean    Vmean    Wmean    uu    vv    ww    uv    TKE',
     $'   Psimean  Upolymean    Psi   u_tau   Ucomb'  

         open(unit=88,file='comp_prof8.dat')
         write(88,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', 0.0,
     $     '%u_tau_poly = ', u_tau_poly, '%u_tau_tot = ', u_tau_tot,
     $     '%ut_avg_fit_top  = ', ut_avg_fit_top,  
     $     '%ut_avg_fit_bot  = ', ut_avg_fit_bot,
     $     '%tau_poly = ', tw_poly, '%tau_en = ', tau_param, 
     $     '%tau_tot = ', tw_tot
         write(88,'(A,A)') 
     $'%  y    Umean    Vmean    Wmean    uu    vv    ww    uv    TKE',
     $'   Psimean  Upolymean    Psi   u_tau   Ucomb'  

         open(unit=89,file='comp_prof9.dat')
         write(89,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', 0.0,
     $     '%u_tau_poly = ', u_tau_poly, '%u_tau_tot = ', u_tau_tot,
     $     '%ut_avg_fit_top  = ', ut_avg_fit_top,  
     $     '%ut_avg_fit_bot  = ', ut_avg_fit_bot,
     $     '%tau_poly = ', tw_poly, '%tau_en = ', tau_param, 
     $     '%tau_tot = ', tw_tot
         write(89,'(A,A)') 
     $'%  y    Umean    Vmean    Wmean    uu    vv    ww    uv    TKE',
     $'   Psimean  Upolymean    Psi   u_tau   Ucomb'  

         open(unit=90,file='comp_prof10.dat')
         write(90,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', 0.0,
     $     '%u_tau_poly = ', u_tau_poly, '%u_tau_tot = ', u_tau_tot,
     $     '%ut_avg_fit_top  = ', ut_avg_fit_top,  
     $     '%ut_avg_fit_bot  = ', ut_avg_fit_bot,
     $     '%tau_poly = ', tw_poly, '%tau_en = ', tau_param, 
     $     '%tau_tot = ', tw_tot
         write(90,'(A,A)') 
     $'%  y    Umean    Vmean    Wmean    uu    vv    ww    uv    TKE',
     $'   Psimean  Upolymean    Psi   u_tau   Ucomb'  

         do i = 1,nint
            yy = yint(i)
            write(56,3) 
     &           yy,
     &           yy*Re_tau,
     &           (stat_y(1*nint+i)-(stat_y(0*nint+i))**2),
     &           stat_y(2*nint+i),
     &           stat_y(3*nint+i),
     &           stat_y(4*nint+i),
     &           u_tau

            write(57,3) 
     &           yy,
     &           yy*Re_tau, 
     &           stat_y(0*nint+i),
     &           stat_y(5*nint+i),
     &           0.0, !stat_y(9*nint+i),
     &           0.0, !stat_y(10*nint+i),
     &           0.0, !psix_int(i),
     &           u_tau, !u_tau_out,
     &           stat_y(0*nint+i) !stat_y(10*nint+i)+psix_int(i)

            write(81,3) 
     &           yint1(i),
     &           stat_y1(0*nint+i),
     &           stat_y1(1*nint+i),
     &           stat_y1(2*nint+i),
     &           (stat_y1(3*nint+i)-(stat_y1(0*nint+i))**2),
     &           (stat_y1(4*nint+i)-(stat_y1(1*nint+i))**2),
     &           (stat_y1(5*nint+i)-(stat_y1(2*nint+i))**2),
     &           stat_y1(6*nint+i)-stat_y1(0*nint+i)*stat_y1(1*nint+i),
     &           0.5*((stat_y1(3*nint+i)-(stat_y1(0*nint+i))**2)+
     &           (stat_y1(4*nint+i)-(stat_y1(1*nint+i))**2)+
     &           (stat_y1(5*nint+i)-(stat_y1(2*nint+i))**2)),
     &           0.0, !stat_y(9*nint+i),
     &           0.0, !stat_y(10*nint+i),
     &           0.0, !psix_int(i),
     &           u_tau, !u_tau_out,
     &           stat_y1(0*nint+i) !stat_y(10*nint+i)+psix_int(i),

            write(82,3) 
     &           yint2(i),
     &           stat_y2(0*nint+i),
     &           stat_y2(1*nint+i),
     &           stat_y2(2*nint+i),
     &           (stat_y2(3*nint+i)-(stat_y2(0*nint+i))**2),
     &           (stat_y2(4*nint+i)-(stat_y2(1*nint+i))**2),
     &           (stat_y2(5*nint+i)-(stat_y2(2*nint+i))**2),
     &           stat_y2(6*nint+i)-stat_y2(0*nint+i)*stat_y2(1*nint+i),
     &           0.5*((stat_y2(3*nint+i)-(stat_y2(0*nint+i))**2)+
     &           (stat_y2(4*nint+i)-(stat_y2(1*nint+i))**2)+
     &           (stat_y2(5*nint+i)-(stat_y2(2*nint+i))**2)),
     &           0.0, !stat_y(9*nint+i),
     &           0.0, !stat_y(10*nint+i),
     &           0.0, !psix_int(i),
     &           u_tau, !u_tau_out,
     &           stat_y2(0*nint+i) !stat_y(10*nint+i)+psix_int(i),
            write(83,3) 
     &           yint3(i),
     &           stat_y3(0*nint+i),
     &           stat_y3(1*nint+i),
     &           stat_y3(2*nint+i),
     &           (stat_y3(3*nint+i)-(stat_y3(0*nint+i))**2),
     &           (stat_y3(4*nint+i)-(stat_y3(1*nint+i))**2),
     &           (stat_y3(5*nint+i)-(stat_y3(2*nint+i))**2),
     &           stat_y3(6*nint+i)-stat_y3(0*nint+i)*stat_y3(1*nint+i),
     &           0.5*((stat_y3(3*nint+i)-(stat_y3(0*nint+i))**2)+
     &           (stat_y3(4*nint+i)-(stat_y3(1*nint+i))**2)+
     &           (stat_y3(5*nint+i)-(stat_y3(2*nint+i))**2)),
     &           0.0, !stat_y(9*nint+i),
     &           0.0, !stat_y(10*nint+i),
     &           0.0, !psix_int(i),
     &           u_tau, !u_tau_out,
     &           stat_y3(0*nint+i) !stat_y(10*nint+i)+psix_int(i),
            write(84,3) 
     &           yint4(i),
     &           stat_y4(0*nint+i),
     &           stat_y4(1*nint+i),
     &           stat_y4(2*nint+i),
     &           (stat_y4(3*nint+i)-(stat_y4(0*nint+i))**2),
     &           (stat_y4(4*nint+i)-(stat_y4(1*nint+i))**2),
     &           (stat_y4(5*nint+i)-(stat_y4(2*nint+i))**2),
     &           stat_y4(6*nint+i)-stat_y4(0*nint+i)*stat_y4(1*nint+i),
     &           0.5*((stat_y4(3*nint+i)-(stat_y4(0*nint+i))**2)+
     &           (stat_y4(4*nint+i)-(stat_y4(1*nint+i))**2)+
     &           (stat_y4(5*nint+i)-(stat_y4(2*nint+i))**2)),
     &           0.0, !stat_y(9*nint+i),
     &           0.0, !stat_y(10*nint+i),
     &           0.0, !psix_int(i),
     &           u_tau, !u_tau_out,
     &           stat_y4(0*nint+i) !stat_y(10*nint+i)+psix_int(i),
            write(85,3) 
     &           yint5(i),
     &           stat_y5(0*nint+i),
     &           stat_y5(1*nint+i),
     &           stat_y5(2*nint+i),
     &           (stat_y5(3*nint+i)-(stat_y5(0*nint+i))**2),
     &           (stat_y5(4*nint+i)-(stat_y5(1*nint+i))**2),
     &           (stat_y5(5*nint+i)-(stat_y5(2*nint+i))**2),
     &           stat_y5(6*nint+i)-stat_y5(0*nint+i)*stat_y5(1*nint+i),
     &           0.5*((stat_y5(3*nint+i)-(stat_y5(0*nint+i))**2)+
     &           (stat_y5(4*nint+i)-(stat_y5(1*nint+i))**2)+
     &           (stat_y5(5*nint+i)-(stat_y5(2*nint+i))**2)),
     &           0.0, !stat_y(9*nint+i),
     &           0.0, !stat_y(10*nint+i),
     &           0.0, !psix_int(i),
     &           u_tau, !u_tau_out,
     &           stat_y5(0*nint+i) !stat_y(10*nint+i)+psix_int(i),
            write(86,3) 
     &           yint6(i),
     &           stat_y6(0*nint+i),
     &           stat_y6(1*nint+i),
     &           stat_y6(2*nint+i),
     &           (stat_y6(3*nint+i)-(stat_y6(0*nint+i))**2),
     &           (stat_y6(4*nint+i)-(stat_y6(1*nint+i))**2),
     &           (stat_y6(5*nint+i)-(stat_y6(2*nint+i))**2),
     &           stat_y6(6*nint+i)-stat_y6(0*nint+i)*stat_y6(1*nint+i),
     &           0.5*((stat_y6(3*nint+i)-(stat_y6(0*nint+i))**2)+
     &           (stat_y6(4*nint+i)-(stat_y6(1*nint+i))**2)+
     &           (stat_y6(5*nint+i)-(stat_y6(2*nint+i))**2)),
     &           0.0, !stat_y(9*nint+i),
     &           0.0, !stat_y(10*nint+i),
     &           0.0, !psix_int(i),
     &           u_tau, !u_tau_out,
     &           stat_y6(0*nint+i) !stat_y(10*nint+i)+psix_int(i),
            write(87,3) 
     &           yint7(i),
     &           stat_y7(0*nint+i),
     &           stat_y7(1*nint+i),
     &           stat_y7(2*nint+i),
     &           (stat_y7(3*nint+i)-(stat_y7(0*nint+i))**2),
     &           (stat_y7(4*nint+i)-(stat_y7(1*nint+i))**2),
     &           (stat_y7(5*nint+i)-(stat_y7(2*nint+i))**2),
     &           stat_y7(6*nint+i)-stat_y7(0*nint+i)*stat_y7(1*nint+i),
     &           0.5*((stat_y7(3*nint+i)-(stat_y7(0*nint+i))**2)+
     &           (stat_y7(4*nint+i)-(stat_y7(1*nint+i))**2)+
     &           (stat_y7(5*nint+i)-(stat_y7(2*nint+i))**2)),
     &           0.0, !stat_y(9*nint+i),
     &           0.0, !stat_y(10*nint+i),
     &           0.0, !psix_int(i),
     &           u_tau, !u_tau_out,
     &           stat_y7(0*nint+i) !stat_y(10*nint+i)+psix_int(i),
            write(88,3) 
     &           yint8(i),
     &           stat_y8(0*nint+i),
     &           stat_y8(1*nint+i),
     &           stat_y8(2*nint+i),
     &           (stat_y8(3*nint+i)-(stat_y8(0*nint+i))**2),
     &           (stat_y8(4*nint+i)-(stat_y8(1*nint+i))**2),
     &           (stat_y8(5*nint+i)-(stat_y8(2*nint+i))**2),
     &           stat_y8(6*nint+i)-stat_y8(0*nint+i)*stat_y8(1*nint+i),
     &           0.5*((stat_y8(3*nint+i)-(stat_y8(0*nint+i))**2)+
     &           (stat_y8(4*nint+i)-(stat_y8(1*nint+i))**2)+
     &           (stat_y8(5*nint+i)-(stat_y8(2*nint+i))**2)),
     &           0.0, !stat_y(9*nint+i),
     &           0.0, !stat_y(10*nint+i),
     &           0.0, !psix_int(i),
     &           u_tau, !u_tau_out,
     &           stat_y8(0*nint+i) !stat_y(10*nint+i)+psix_int(i),
            write(89,3) 
     &           yint9(i),
     &           stat_y9(0*nint+i),
     &           stat_y9(1*nint+i),
     &           stat_y9(2*nint+i),
     &           (stat_y9(3*nint+i)-(stat_y9(0*nint+i))**2),
     &           (stat_y9(4*nint+i)-(stat_y9(1*nint+i))**2),
     &           (stat_y9(5*nint+i)-(stat_y9(2*nint+i))**2),
     &           stat_y9(6*nint+i)-stat_y9(0*nint+i)*stat_y9(1*nint+i),
     &           0.5*((stat_y9(3*nint+i)-(stat_y9(0*nint+i))**2)+
     &           (stat_y9(4*nint+i)-(stat_y9(1*nint+i))**2)+
     &           (stat_y9(5*nint+i)-(stat_y9(2*nint+i))**2)),
     &           0.0, !stat_y(9*nint+i),
     &           0.0, !stat_y(10*nint+i),
     &           0.0, !psix_int(i),
     &           u_tau, !u_tau_out,
     &           stat_y9(0*nint+i) !stat_y(10*nint+i)+psix_int(i),
            write(90,3) 
     &           yint10(i),
     &           stat_y10(0*nint+i),
     &           stat_y10(1*nint+i),
     &           stat_y10(2*nint+i),
     &           (stat_y10(3*nint+i)-(stat_y10(0*nint+i))**2),
     &           (stat_y10(4*nint+i)-(stat_y10(1*nint+i))**2),
     &           (stat_y10(5*nint+i)-(stat_y10(2*nint+i))**2),
     &         stat_y10(6*nint+i)-stat_y10(0*nint+i)*stat_y10(1*nint+i),
     &           0.5*((stat_y10(3*nint+i)-(stat_y10(0*nint+i))**2)+
     &           (stat_y10(4*nint+i)-(stat_y10(1*nint+i))**2)+
     &           (stat_y10(5*nint+i)-(stat_y10(2*nint+i))**2)),
     &           0.0, !stat_y(9*nint+i),
     &           0.0, !stat_y(10*nint+i),
     &           0.0, !psix_int(i),
     &           u_tau, !u_tau_out,
     &           stat_y10(0*nint+i) !stat_y(10*nint+i)+psix_int(i),


  3         format(1p15e17.9)
         enddo
         close(56)
         close(57)
         close(81)
         close(82)
         close(83)
         close(84)
         close(85)
         close(86)
         close(87)
         close(88)
         close(89)
         close(90)

 998  endif      
      
      return
      end

c-----------------------------------------------------------------------
c     WALL FUNCTIONS DEFINED HERE 
      real function f(x,flag,up,yp,rho,mu)
      real x,up,yp,rho,mu   !yp,up,rho,and mu are the location,velocity
                            !,density and dyn.viscosity for the matching 
                            !point; x is the unknown (utau at the wall)
      integer flag

      if (flag .eq. 1) then
        f = up/x-(1/0.41)*log(yp*rho*x/mu)-5.17 ! Classical Log Law
      else if (flag .eq. 2) then
        f = up/x-(1/0.41)*log(1+0.41*yp*rho*x/mu)-7.8*
     $      (1-exp(-yp*rho*x/(11*mu))-
     $      yp*rho*x/(11*mu)*exp(-yp*rho*x/(3*mu))) ! Reichardt
      endif

      return
      end
c----------------------------------------------------------------------
c     WALL FUNCTION DERIVATIVES DEFINED HERE (used in N-R solver)
      real function fprime(x,flag,up,yp,rho,mu)
      real x,up,yp,rho,mu   !yp,up,rho,and mu are the location,velocity
                            !,density and dyn.viscosity for the matching
                            !point; x is the unknown (utau at the wall)
      integer flag

      if (flag .eq. 1) then
        fprime = -up/x**2-1/(0.41*x) ! Classical Log Law
      else if (flag .eq. 2) then
        fprime = -up/x**2-yp*rho/(mu*(1+0.41*yp*rho*x/mu))-7.8*
     $     (yp*rho/(11*mu)*exp(-yp*rho*x/(11*mu))-
     $      yp*rho/(11*mu)*exp(-yp*rho*x/(3*mu))+x/33*(yp*rho/mu)**2*
     $     exp(-yp*rho*x/(3*mu))) ! Reichardt
      endif

      return
      end
c----------------------------------------------------------------------
c     NEWTON-RAPHSON SOLVER     
      real function newton(flag,up,yp,rho,mu,xi,rtol,maxiter)  
      implicit none
      integer flag,maxiter,i
      real up,yp,rho,mu,xi,rtol,eps,x,fx,fx1,fx2,xnew,fprime,f,fpr,fnew
      real atol 

      eps = 1.0e-14
      atol = 1.0e-14 
      newton = 0.0 ! assigned if the solution does not converge 
      x = xi
      fx = f(x,flag,up,yp,rho,mu)
      do i = 1,max(1,maxiter)
c        fx=f(x,flag,up,yp,rho,mu)
        fx1=f(x-eps,flag,up,yp,rho,mu)
        fx2=f(x+eps,flag,up,yp,rho,mu)
        fpr=(fx2-fx1)/(2*eps) ! calculate numerical derivative
c        fpr=fprime(x,flag,up,yp,rho,mu)!calculate analytical derivative
        xnew=x-fx/fpr
        fnew=f(xnew,flag,up,yp,rho,mu)
        if(abs((xnew-x)/xnew).le.rtol .AND. abs(fnew).le.atol) then
c        if(abs((xnew-x)/xnew).le.rtol) then
c        if(abs(fnew).le.atol) then
          newton=xnew
          exit
        endif
        x=xnew
        fx=fnew
      enddo
      
c      write(6,*) 'i, newton, xnew, f = ', i, newton, xnew,
c     $ f(newton,flag,up,yp,rho,mu)      

      return
      end
c---------------------------------------------------------------------
c     SECANT SOLVER 
      real function secant(flag,up,yp,rho,mu,xi1,xi2,rtol,maxiter)
      implicit none
      integer flag,maxiter,i
      real up,yp,rho,mu,xi1,xi2,rtol,x,fx,xprev,fxprev,xnew,f

      secant = 0.0  ! assigned if the solution does not converge
      x = xi2
      xprev = xi1
      fxprev=f(xprev,flag,up,yp,rho,mu)
      do i = 1,max(1,maxiter)
        fx=f(x,flag,up,yp,rho,mu)
        xnew=x-fx*(xprev-x)/(fxprev-fx)
        if(abs((xnew-x)/xnew).le.rtol) then
          secant=xnew
          exit
        endif
        fxprev=fx
        xprev=x
        x=xnew
      enddo

c      write(6,*) 'i, secant, f = ', i, secant, 
c     $ f(secant,flag,up,yp,rho,mu)

      return
      end
c---------------------------------------------------------------------
c     BISECTION SOLVER (not tested)
c      implicit none
c      real function bisection(flag,up,yp,rho,mu,a,b,atol,maxiter)
c      integer flag,maxiter,i
c      real up,yp,rho,mu,a,b,c,atol,fa,fc,f
c
c      bisection = 0.0
c      do i = 1,max(1,maxiter)
c        c=(a+b)/2
c        fc=f(c,flag,up,yp,rho,mu)
c        fa=f(a,flag,up,yp,rho,mu)
c        if((b-a)/2.le.atol .OR. fc.eq.0) then
c          bisection=c
c          exit
c        endif
c      if(fc/abs(fc) .eq. fa/abs(fa)) then
c        a=c
c      else b=c
c      endif 
c      enddo

c      write(6,*) 'i, bisection, f = ', i, bisection, 
c     $ f(bisection,flag,up,yp,rho,mu)

c      return
c      end
c-------------------------------------------------------------------
c-----------------------------------------------------------------------
      subroutine interp_v(uvw,xyz,n)
c
c     evaluate velocity for list of points xyz
c
      include 'SIZE'
      include 'TOTAL'

      real uvw(ldim,n),xyz(ldim,n)

      real    rwk(LPTS,ldim+1) ! r, s, t, dist2
      integer iwk(LPTS,3)      ! code, proc, el
      save    rwk, iwk

      integer intp_h
      save    intp_h

      common /rwk_intp/
     $       fwrk(lx1*ly1*lz1*lelt,ldim),
     $       fpts(ldim*LPTS),
     $       pts(ldim*LPTS)

      integer icalld,e
      save    icalld
      data    icalld /0/

      nxyz  = nx1*ny1*nz1
      ntot  = nxyz*nelt

      if (n.gt.LPTS) call exitti ('n > LPTS in interp_v!$',n)

      if (nelgt.ne.nelgv) call exitti
     $   ('nelgt.ne.nelgv not yet supported in interp_v!$',nelgv)

      do i=1,n                          ! ? not moving -> save?
         pts(i)     = xyz(1,i)
         pts(i + n) = xyz(2,i)
         if (if3d) pts(i + n*2) = xyz(3,i)
      enddo

      if (icalld.eq.0) then
        icalld = 1
        call interp_setup(intp_h,0.0,0,nelt)
      endif

      ! pack working array
      call opcopy(fwrk(1,1),fwrk(1,2),fwrk(1,3),vx,vy,vz)

      ! interpolate
      call interp_nfld(fpts,fwrk,ndim,pts(1),pts(1+n),pts(2*n+1),
     $                 n,iwk,rwk,LPTS,.true.,intp_h)

      do i=1,n
         uvw(1,i) = fpts(i)
         uvw(2,i) = fpts(i + n)
         if(if3d) uvw(3,i) = fpts(i + n*2)
      enddo

      return
      end

c-----------------------------------------------------------------------
      subroutine shear_stress(cf,cf_top,cp,cp_top,xf,u,v,w,pr_in)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'ZPER'  ! nelz

      parameter (lt=lx1*ly1*lz1*lelt,lxyz=lx1*ly1*lz1)
      integer nelx2, nely2, nelz2
      parameter (nelx2=NUMBER_ELEMENTS_X, 
     $   nely2=NUMBER_ELEMENTS_Y, nelz2=NUMBER_ELEMENTS_Z)

      real cf(lx1,nelx2),cf_top(lx1,nelx2),
     $     cp(lx1,nelx2),cp_top(lx1,nelx2),
     $     xf(lx1,nelx2),u(lt),v(lt),w(lt),pr_in(lt)

      real pra(lx1,ly1,lz1,lelt)

      common /scrns/ sij(lxyz,3*(ldim-1),lelt)
      common /scruz/ ua(lt),va(lt),wa(lt)
      common /scrmg/ ur (lxyz) , us (lxyz) , ut (lxyz)
     $             , vr (lxyz) , vs (lxyz) , vt (lxyz)
     $             , wr (lxyz) , ws (lxyz) , wt (lxyz)


      integer icalld,igs_z,e,eg,ex,ey,ez,f
      save    icalld,igs_z
      data    icalld /0/

      n     =   lx1*ly1*lz1*nelv


c     ! average field in z and then in x
      idir = 3 ! z
      if (icalld.eq.0) call gtpp_gs_setup(igs_z,nelx2,nely2,nelz2,idir)
      icalld=1

      call planar_avg(ua,u,igs_z)
      call planar_avg(va,v,igs_z)
      call planar_avg(wa,w,igs_z)
      call planar_avg(pra,pr_in,igs_z)

      umax=glamax(ua,n)

      nij = 3*(ldim-1)
      call comp_sij(sij,nij,ua,va,wa,ur,us,ut,vr,vs,vt,wr,ws,wt)

      npts = lx1*nelx2
      call rzero(cf,npts)
      call rzero(cf_top,npts)
      call rzero(cp,npts)
      call rzero(cp_top,npts)
      call rzero(xf,npts)

      f=1 ! Face 1
      f_top = 3

      visc = param(2)

      do e=1,nelv
        eg = lglel(e)
        call get_exyz(ex,ey,ez,eg,nelx2,nely2,nelz2)

        if (ey.eq.1.and.ez.eq.1) then

          do k=1,lx1

            sxx = sij(k,1,e)
            syy = sij(k,2,e)
            syx = sij(k,ldim+1,e)

            tnx = -uny(k,1,f,e)
            tny =  unx(k,1,f,e)

            cf(k,ex) = tnx*sxx*unx(k,1,f,e) 
     $               + tny*syx*unx(k,1,f,e) 
     $               + tnx*syx*uny(k,1,f,e) 
     $               + tny*syy*uny(k,1,f,e) 
            cf(k,ex) = -visc*cf(k,ex)
            xf(k,ex) =  xm1(k,1,1,e)
            cp(k,ex) = pra(k,1,1,e)

          enddo
        endif
        if (ey.eq.nely2.and.ez.eq.1) then

          do k=1,lx1

            sxx = sij((ly1-1)*lx1+k,1,e)
            syy = sij((ly1-1)*lx1+k,2,e)
            syx = sij((ly1-1)*lx1+k,ldim+1,e)

            tnx = -uny(k,1,f_top,e)
            tny = unx(k,1,f_top,e)

            cf_top(k,ex) = tnx*sxx*unx(k,1,f_top,e) 
     $                   + tny*syx*unx(k,1,f_top,e) 
     $                   + tnx*syx*uny(k,1,f_top,e) 
     $                   + tny*syy*uny(k,1,f_top,e) 
            cf_top(k,ex) = visc*cf_top(k,ex)
            cp_top(k,ex) = pra(k,ly1,1,e)
          enddo
        endif
      enddo

      call gop(cf,ua,'+  ',npts) ! Sum cf vector over all ranks
      call gop(cf_top,ua,'+  ',npts) ! Sum cf vector over all ranks
      call gop(cp,ua,'+  ',npts) ! Sum cf vector over all ranks
      call gop(cp_top,ua,'+  ',npts) ! Sum cf vector over all ranks
      call gop(xf,ua,'+  ',npts) ! Sum cf vector over all ranks

      return
      end
