c- constants -----------------------------------------------------------

#define tSTATSTART uparam(1) /* start time for averaging */
#define tSTATFREQ  uparam(2) /* output frequency for statistics */

c data extraction along wall normal direction
#define INTP_NMAX 2000 /* number of sample points */
#define XCINT 1.0     /* x coordinate of 1D line*/
#define ZCINT 1.0     /* z coordinate of 1D line */

c mesh dimensions
#define BETAM 2.4     /* wall normal stretching parameter */
#define PI (4.*atan(1.))
#define XLEN (2.*PI)
#define ZLEN PI
#define NUMBER_ELEMENTS_X 8
#define NUMBER_ELEMENTS_Y 14
#define NUMBER_ELEMENTS_Z 8

c MA
#define LPTS 1000
#define deltaw 0.14285714285 /*Matching location*/
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e

      utrans = 1.
      udiff  = param(2)

      if (ifield .eq. 2) then
         e = gllel(ieg)
         udiff = param(8)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ffx = 0.0 
      ffy = 0.0
      ffz = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      qvol =  0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'

      real x0(3)
      data x0 /0.0, 0.0, 0.0/ 
      save x0

      integer icalld
      save    icalld
      data    icalld /0/

      real atime,timel
      save atime,timel

      integer ntdump
      save    ntdump

      real    rwk(INTP_NMAX,ldim+1) ! r, s, t, dist2
      integer iwk(INTP_NMAX,3)      ! code, proc, el 
      save    rwk, iwk

      integer nint, intp_h
      save    nint, intp_h

      logical iffpts
      save iffpts

      real xint(INTP_NMAX),yint(INTP_NMAX),zint(INTP_NMAX)
      save xint, yint, zint
      save igs_x, igs_z

      parameter(nstat=9)
      real ravg(lx1*ly1*lz1*lelt,nstat)
      real stat(lx1*ly1*lz1*lelt,nstat)
      real stat_y(INTP_NMAX*nstat)
      save ravg, stat, stat_y

      save dragx_avg
      save dragz_avg

      logical ifverbose
      common /gaaa/    wo1(lx1,ly1,lz1,lelv)
     &              ,  wo2(lx1,ly1,lz1,lelv)
     &              ,  wo3(lx1,ly1,lz1,lelv)

      integer flag(lelv)
      common /beflag/ flag

c----------------------------------------------------------------
c     VARIABLES DECLARED FOR USING THE NON-ITERATIVE METHOD  
      real tauold(lx1,ly1,lz1,lelv), taunewx(lx1,ly1,lz1,lelv)
      real taunewy(lx1,ly1,lz1,lelv), taunewz(lx1,ly1,lz1,lelv)
      common /wallshear/ taunewx,taunewy,taunewz
      save tauold
      
      real M, Kappa, utau_init
      data M/5.17/, kappa/0.41/, utau_init/0.2/
      save M, kappa, utau_init
c----------------------------------------------------------------
c     VARIABLES DECLARED FOR USING THE ITERATIVE METHOD 
      real newton,secant,rtol,ut0,ut1,uti(lx1,ly1,lz1,lelv),utau
      integer flg, maxiter, count
      data rtol/1.0e-5/, maxiter/20000/
      data flg/2/, count/0/ !flg = flag for the chosen wall model
c      data uti/0.2/  !Initial guess value of utau for Newton Method
      data ut0/0.04/, ut1/0.08/ !Initial guess values for Secant Method
      save rtol, maxiter, flg, uti, ut0, ut1
c---------------------------------------------------------------
c     VARIABLES DECLARED FOR GENERAL WALL !MA
      character*3 cb
      integer npts
      real xmp,ymp,zmp
      real x1(ldim,LPTS),u1(ldim,LPTS)
      real*8 unw(ldim,LPTS),t1w(ldim,LPTS),t2w(ldim,LPTS)
      real*8 utt1,utt2,utgt,utgtx,utgty,utgtz,utgtmag
c---------------------------------------------------------------


      real tplus
      real tmn, tmx   

      integer bIDs(1)
      save iobj_wall

      n     = nx1*ny1*nz1*nelv
      nelx  = NUMBER_ELEMENTS_X
      nely  = NUMBER_ELEMENTS_Y
      nelz  = NUMBER_ELEMENTS_Z

c MA
      nface = 2*ldim
c 

      if (istep.eq.0) then
         bIDs(1) = 1
         call create_obj(iobj_wall,bIDs,1)
         nm = iglsum(nmember(iobj_wall),1)
         if(nid.eq.0) write(6,*) 'obj_wall nmem:', nm 
         call prepost(.true.,'  ')
      endif

      ubar = glsc2(vx,bm1,n)/volvm1
      e2   = glsc3(vy,bm1,vy,n)+glsc3(vz,bm1,vz,n)
      e2   = e2/volvm1
      if (nfield.gt.1) then
        tmn  = glmin(t,n)
        tmx  = glmax(t,n)
      endif
      if(nid.eq.0) write(6,2) time,ubar,e2,tmn,tmx
   2               format(1p5e13.4,' monitor')

c     EQUILIBRIUM WALL STRESS MODEL...START

c     Currently all the lines for the non-iterative method are commented
c     For iterative method: up,yp = velocity,location of matching point
c     For non-iterative method: up,yp = uplus,yplus of matching point

      if (istep.eq.0) then
         do iel = 1, nelv
          do ix = 1, lx1
           do iy = 1, ly1
            do iz = 1, lz1
c              tauold(ix,iy,iz,iel) = param(1)*(utau_init)**2
               tauold(ix,iy,iz,iel)=0.0
               uti(ix,iy,iz,iel) = 0.08 ! Guess value for N-R solver
            enddo
           enddo
          enddo
         enddo
      endif

      if (time.le.50) then
         do iel = 1, nelv
          do ix = 1, lx1
           do iy = 1, ly1
            do iz = 1, lz1
              taunewx(ix,iy,iz,iel) = 0.0
              taunewy(ix,iy,iz,iel) = 0.0
              taunewz(ix,iy,iz,iel) = 0.0
            enddo
           enddo
          enddo
         enddo

      else
c MA - start
      npts=0
      do iel=1,nelv
        do iface=1,nface
          cb  = cbc (iface,iel,1)
          if(cb.eq.'sh ') then
c Find the gll points on the wall faces
            ia=0
            CALL FACIND (KX1,KX2,KY1,KY2,KZ1,KZ2,NX1,NY1,NZ1,IFACE)
            do ix=kx1,kx2
            do iy=ky1,ky2
            do iz=kz1,kz2
c Find the normal vector at these points
              ia=ia+1
              npts=npts+1
              unw(1,npts)=unx(ia,1,iface,iel)
              unw(2,npts)=uny(ia,1,iface,iel)
              unw(3,npts)=unz(ia,1,iface,iel)
              t1w(1,npts)=t1x(ia,1,iface,iel)
              t1w(2,npts)=t1y(ia,1,iface,iel)
              t1w(3,npts)=t1z(ia,1,iface,iel)
              t2w(1,npts)=t2x(ia,1,iface,iel)
              t2w(2,npts)=t2y(ia,1,iface,iel)
              t2w(3,npts)=t2z(ia,1,iface,iel)
c Find the coordinates at a distance delta along the normal vector
              xmp=xm1(ix,iy,iz,iel)-deltaw*unw(1,npts)
              ymp=ym1(ix,iy,iz,iel)-deltaw*unw(2,npts)
              zmp=zm1(ix,iy,iz,iel)-deltaw*unw(3,npts)
              x1(1,npts)=xmp
              x1(2,npts)=ymp
              x1(3,npts)=zmp
            enddo
            enddo
            enddo
          endif
        enddo
      enddo
c Find the velocity and scalar values at this point
      call interp_v(u1,x1,npts)
      npts=0
      do iel=1,nelv
        do iface=1,nface
          cb  = cbc (iface,iel,1)
          if(cb.eq.'sh ') then
c Find the gll points on the wall faces
            CALL FACIND (KX1,KX2,KY1,KY2,KZ1,KZ2,NX1,NY1,NZ1,IFACE)
            do ix=kx1,kx2
            do iy=ky1,ky2
            do iz=kz1,kz2
              npts=npts+1
              utt1=t1w(1,npts)*u1(1,npts)+t1w(2,npts)*u1(2,npts)+
     $            t1w(3,npts)*u1(3,npts)
              utt2=t2w(1,npts)*u1(1,npts)+t2w(2,npts)*u1(2,npts)+
     $            t2w(3,npts)*u1(3,npts)
              utgt=(utt1**2+utt2**2)**(0.5)
              utgtx=utt1*t1w(1,npts)+utt2*t2w(1,npts)
              utgty=utt1*t1w(2,npts)+utt2*t2w(2,npts)
              utgtz=utt1*t1w(3,npts)+utt2*t2w(3,npts)
              utgtmag=(utgtx**2+utgty**2+utgtz**2)**(0.5)
              utgtx=utgtx/utgtmag
              utgty=utgty/utgtmag
              utgtz=utgtz/utgtmag
              tauold(ix,iy,iz,iel)=utgtz/utgtx

              yp=deltaw
              up=utgt
      utau = newton(flg,up,yp,param(1),param(2),uti(ix,iy,iz,iel),rtol,
     $              maxiter)
c      utau = secant(flg,up,yp,param(1),param(2),ut0,ut1,rtol,maxiter)
      if (utau .eq. 0.0) count = count + 1 ! count unconverged solutions
      if (utau .ne. 0.0) uti(ix,iy,iz,iel) = utau ! update guess value
                                                   ! for next time step
               taunewx(ix,iy,iz,iel) = -param(1)*utau**2*utgtx ! shear stress
c               taunewx(ix,iy,iz,iel) = -param(1)*utau**2 ! shear stress
               taunewy(ix,iy,iz,iel) = -param(1)*utau**2*utgty ! shear stress
               taunewz(ix,iy,iz,iel) = -param(1)*utau**2*utgtz ! shear stress
      if (utau .eq. 0.0) then 
               taunewx(ix,iy,iz,iel) = -param(1)*(uti(ix,iy,iz,iel)**2)
     $                                *utgtx 
               taunewy(ix,iy,iz,iel) = -param(1)*(uti(ix,iy,iz,iel)**2)
     $                                *utgty 
               taunewz(ix,iy,iz,iel) = -param(1)*(uti(ix,iy,iz,iel)**2)
     $                                *utgtz 
      endif
            enddo
            enddo
            enddo
          endif
        enddo
      enddo
c MA - end
c      call outpost(taunewx,taunewy,taunewz,pr,t,'   ')
c      call exitt

      count = iglsum(count,1)

      if(nid.eq.0) then
       write(6,*) 'Solutions not converged: ', count
      endif

      count = 0
      utaumax=glmax(uti,n)
      utaumin=glmin(uti,n)
      if(nid.eq.0) write(6,*) utaumax,utaumin,'utau'      
      tauxmax=glmax(taunewx,n)
      tauxmin=glmin(taunewx,n)
      if(nid.eq.0) write(6,*) tauxmax,tauxmin,'taux'
      tauzmax=glmax(taunewz,n)
      tauzmin=glmin(taunewz,n)
      if(nid.eq.0) write(6,*) tauzmax,tauzmin,'tauz'
      tauzmax=glmax(tauold,n)
      tauzmin=glmin(tauold,n)
      if(nid.eq.0) write(6,*) tauzmax,tauzmin,'tgt z/x'
      endif

c      do iel = 1, nelv
c       do ix = 1, lx1
c        do iy = 1, ly1
c         do iz = 1, lz1
c           tauold(ix,iy,iz,iel) = -taunew(ix,iy,iz,iel)
c         enddo
c        enddo
c       enddo
c      enddo

c     EQUILIBRIUM WALL STRESS MODEL...END


      if (time.lt.tSTATSTART) return


c     What follows computes some statistics ...
c

      if(ifoutfld) then
        if (ldimt.ge.2) call lambda2(t(1,1,1,1,2))
        if (ldimt.ge.3) call comp_vort3(t(1,1,1,1,3),wo1,wo2,vx,vy,vz)
      endif

      if(icalld.eq.0) then
        if(nid.eq.0) write(6,*) 'Start collecting statistics ...'

        nxm = 1 ! mesh is linear
        call interp_setup(intp_h,0.0,nxm,nelt)
        nint = 0
        if (nid.eq.0) then
          nint = INTP_NMAX
          call cfill(xint,XCINT,size(xint))
          do i = 1,INTP_NMAX 
             yi = (i-1.)/(INTP_NMAX-1)
             yint(i) = tanh(BETAM*(2*yi-1))/tanh(BETAM)
          enddo
          call cfill(zint,ZCINT,size(zint))
        endif
        iffpts = .true. ! dummy call to find points
        call interp_nfld(stat_y,ravg,1,xint,yint,zint,nint,
     $                   iwk,rwk,INTP_NMAX,iffpts,intp_h)
        iffpts = .false.
        call gtpp_gs_setup(igs_x,nelx     ,nely,nelz,1) ! x-avg
        call gtpp_gs_setup(igs_z,nelx*nely,1   ,nelz,3) ! z-avg

        call rzero(ravg,size(ravg))
        dragx_avg = 0
        dragz_avg = 0
        atime     = 0
        timel     = time
        ntdump    = int(time/tSTATFREQ)

        icalld = 1
      endif

      dtime = time - timel
      atime = atime + dtime

      ! averaging over time
      if (atime.ne.0. .and. dtime.ne.0.) then
        beta      = dtime / atime
        alpha     = 1. - beta

        ifverbose = .false.
        call avg1(ravg(1,1),vx   ,alpha,beta,n,'uavg',ifverbose)
        call avg2(ravg(1,2),vx   ,alpha,beta,n,'urms',ifverbose)
        call avg2(ravg(1,3),vy   ,alpha,beta,n,'vrms',ifverbose)
        call avg2(ravg(1,4),vz   ,alpha,beta,n,'wrms',ifverbose)
        call avg3(ravg(1,5),vx,vy,alpha,beta,n,'uvmm',ifverbose)

        call avg1(ravg(1,6),t    ,alpha,beta,n,'tavg',ifverbose)
        call avg2(ravg(1,7),t    ,alpha,beta,n,'trms',ifverbose)
        call avg3(ravg(1,8),vx,t ,alpha,beta,n,'utmm',ifverbose)
        call avg3(ravg(1,9),vy,t ,alpha,beta,n,'vtmm',ifverbose)

        call torque_calc(1.0,x0,.false.,.false.) ! compute wall shear
        dragx_avg = alpha*dragx_avg + beta*dragx(iobj_wall)
        dragz_avg = alpha*dragz_avg + beta*dragz(iobj_wall)
       if(nid.eq.0)  write(6,*) 'dragx(iobj_wall) = ', dragx(iobj_wall)
       if(nid.eq.0)  write(6,*) 'dragz(iobj_wall) = ', dragz(iobj_wall)
      endif
      
c      write(6,*) 'dragx_avg = ', dragx_avg

      timel = time

      ! write statistics to file
      if(istep.gt.0 .and. time.gt.(ntdump+1)*tSTATFREQ) then
         ! averaging over statistical homogeneous directions (x-z)
         do i = 1,nstat
            call planar_avg(wo1      ,ravg(1,i),igs_x)
            call planar_avg(stat(1,i),wo1      ,igs_z)
         enddo

         if (nfield.gt.1) then
            ! evaluate d<T>/dy at the lower wall
            call opgrad(wo1,wo2,wo3,stat(1,6))
            call dssum(wo2,lx1,ly1,lz1)
            call col2(wo2,binvm1,n)
            call interp_nfld(stat_y,wo2,1,xint,yint,zint,nint,
     $                       iwk,rwk,INTP_NMAX,iffpts,intp_h)
            dTdy_w = stat_y(1)
         else
            dTdy_w = 1.
         endif

         ! extract data along wall normal direction (1D profile)
         call interp_nfld(stat_y,stat,nstat,xint,yint,zint,nint,
     $                    iwk,rwk,INTP_NMAX,iffpts,intp_h)

         ntdump = ntdump + 1
         if (nid.ne.0) goto 998 

         rho    = param(1)
         dnu    = param(2)
         A_w    = 2 * XLEN 
         if (ldim == 3) A_w = A_w*ZLEN
         tw     = dragx_avg / A_w
         u_tau  = sqrt(tw / rho)
         qw     = -param(8) * dTdy_w
         t_tau  = 1/u_tau * qw
         Re_tau = u_tau / dnu
         tplus  = time * u_tau**2 / dnu

         write(6,*) 'Dumping statistics ...', Re_tau, u_tau, dragx_avg, 
     $    tw, A_w
 
         open(unit=56,file='vel_fluc_prof.dat')
         write(56,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', 0.0
         write(56,'(A)') 
     $    '%  y    y+    uu    vv    ww    uv    u_tau   '

         open(unit=57,file='mean_prof.dat')
         write(57,'(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)(A,1pe14.7)') 
     $     '%time = ', time, '%Re_tau = ', Re_tau, 
     $     '%ut = ', u_tau, '%ut_param = ', u_tau, 
     $     '%u_tau_poly = ', u_tau, '%u_tau_tot = ', u_tau,
     $     '%ut_avg_fit_top  = ', 0.0,  
     $     '%ut_avg_fit_bot  = ', 0.0,
     $     '%tau_poly = ', tw, '%tau_en = ', 0.0, 
     $     '%tau_tot = ', tw
         write(57,'(A)') 
     $'%  y    y+    Umean    Psimean  Upolymean    Psi   u_tau   Ucomb'

         do i = 1,nint
            yy = 1+yint(i)
            write(56,3) 
     &           yy,
     &           yy*Re_tau,
     &           (stat_y(1*nint+i)-(stat_y(0*nint+i))**2),
     &           stat_y(2*nint+i),
     &           stat_y(3*nint+i),
     &           stat_y(4*nint+i),
     &           u_tau

            write(57,3) 
     &           yy,
     &           yy*Re_tau, 
     &           stat_y(0*nint+i),
     &           0.0,
     &           0.0,
     &           0.0,
     &           u_tau,
     &           stat_y(0*nint+i)


  3         format(1p15e17.9)
         enddo
         close(56)
         close(57)

 998  endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      real taunew(lx1,ly1,lz1,lelv)
      common /wallshear/ taunew

      if (y.lt.0) temp = 1.0
      if (y.gt.0) temp = 0.0

      e = gllel(ieg)

c     Imposing shear stress B.C.s
      if(cbc(iside,e,1).eq.'sh ') then
        TRX=taunew(ix,iy,iz,e)
        TRY=0.0
        TRZ=0.0
      endif
      
      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer idum
      save    idum 
      data    idum / 0 /

      real C, k, kx, ky

      Re_tau = 543.496 
      C      = 5.17
      k      = 0.41

      yp = (1-y)*Re_tau
      if (y.lt.0) yp = (1+y)*Re_tau
      
      ! Reichardt function
      ux  = 1/k*log(1+k*yp) + (C - (1/k)*log(k)) *
     $      (1 - exp(-yp/11) - yp/11*exp(-yp/3))
      ux  = ux * Re_tau*param(2)

      eps = 1e-2
      kx  = 23
      kz  = 13

      alpha = kx * 2*PI/XLEN
      beta  = kz * 2*PI/ZLEN 

      ! add perturbation to trigger turbulence 
      ux  = ux  + eps*beta  * sin(alpha*x)*cos(beta*z) 
      uy  =       eps       * sin(alpha*x)*sin(beta*z)
      uz  =      -eps*alpha * cos(alpha*x)*sin(beta*z)

      ! thin boundary layer at the lower wall
      gamma = 5e-6 ! initial thickness
      temp = erfc((1+y)/sqrt(1./param(8) * gamma))

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat   ! This routine to modify element vertices
      include 'SIZE'      ! _before_ mesh is generated, which 
      include 'TOTAL'     ! guarantees GLL mapping of mesh.

      n = nelv * 2**ldim
      xmin = glmin(xc,n)
      xmax = glmax(xc,n)
      ymin = glmin(yc,n)
      ymax = glmax(yc,n)
      zmin = glmin(zc,n)
      zmax = glmax(zc,n)

      xscale = XLEN/(xmax-xmin)
      yscale = 1./(ymax-ymin)
      zscale = ZLEN/(zmax-zmin)

      do i=1,n
         xc(i,1) = xscale*xc(i,1)
         yc(i,1) = 2*yscale*yc(i,1)-1  ! No stretching 
      !   yc(i,1) = tanh(BETAM*(2*yc(i,1)-1))/tanh(BETAM) ! Stretching
         zc(i,1) = zscale*zc(i,1)
      enddo
 
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2   ! This routine to modify mesh coordinates
      include 'SIZE'
      include 'TOTAL'
      
      integer flag(lelv), counterp, countern
      common /beflag/ flag
      
      counterp = 0
      countern = 0

      do iel=1,nelt
      do ifc=1,2*ndim
         if (cbc(ifc,iel,1) .eq. 'sh ') boundaryID(ifc,iel) = 1 
         cbc(ifc,iel,2) = cbc(ifc,iel,1) 
         if (cbc(ifc,iel,1) .eq. 'sh ') cbc(ifc,iel,2) = 't  '
      enddo
      enddo

      ! Flag boundary elements above and below centerline (y = 0)
      do iel=1,nelv
         do ifc=1,2*ldim
           if ((cbc(ifc,iel,1).eq.'sh ').AND.(ym1(1,1,1,iel).gt.0)) then
              flag(iel) = 1
              counterp = counterp+1
           else if ((cbc(ifc,iel,1).eq.'sh ').AND.
     $             (ym1(1,1,1,iel).lt.0)) then
              flag(iel) = -1
              countern = countern+1
           endif
         enddo
      enddo

      counterp = iglsum(counterp,1)
      countern = iglsum(countern,1)

      if (nid.eq.0) then 
          write(6,*) '# Boundary Elements Above Centerline:', counterp
          write(6,*) '# Boundary Elements Below Centerline:', countern
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'

      param(54) = -1  ! use >0 for const flowrate or <0 bulk vel
                      ! flow direction is given by (1=x, 2=y, 3=z) 
      param(55) = 1.0 ! flowrate/bulk-velocity 

      return
      end
c-----------------------------------------------------------------------
c     WALL FUNCTIONS DEFINED HERE 
      real function f(x,flag,up,yp,rho,mu)
      real x,up,yp,rho,mu   !yp,up,rho,and mu are the location,velocity
                            !,density and dyn.viscosity for the matching 
                            !point; x is the unknown (utau at the wall)
      integer flag

      if (flag .eq. 1) then
        f = up/x-(1/0.41)*log(yp*rho*x/mu)-5.17 ! Classical Log Law
      else if (flag .eq. 2) then
        f = up/x-(1/0.41)*log(1+0.41*yp*rho*x/mu)-7.8*
     $      (1-exp(-yp*rho*x/(11*mu))-
     $      yp*rho*x/(11*mu)*exp(-yp*rho*x/(3*mu))) ! Reichardt
      endif

      return
      end
c----------------------------------------------------------------------
c     WALL FUNCTION DERIVATIVES DEFINED HERE (used in N-R solver)
      real function fprime(x,flag,up,yp,rho,mu)
      real x,up,yp,rho,mu   !yp,up,rho,and mu are the location,velocity
                            !,density and dyn.viscosity for the matching
                            !point; x is the unknown (utau at the wall)
      integer flag

      if (flag .eq. 1) then
        fprime = -up/x**2-1/(0.41*x) ! Classical Log Law
      else if (flag .eq. 2) then
        fprime = -up/x**2-yp*rho/(mu*(1+0.41*yp*rho*x/mu))-7.8*
     $     (yp*rho/(11*mu)*exp(-yp*rho*x/(11*mu))-
     $      yp*rho/(11*mu)*exp(-yp*rho*x/(3*mu))+x/33*(yp*rho/mu)**2*
     $     exp(-yp*rho*x/(3*mu))) ! Reichardt
      endif

      return
      end
c----------------------------------------------------------------------
c     NEWTON-RAPHSON SOLVER     
      real function newton(flag,up,yp,rho,mu,xi,rtol,maxiter)  
      implicit none
      integer flag,maxiter,i
      real up,yp,rho,mu,xi,rtol,eps,x,fx,fx1,fx2,xnew,fprime,f,fpr,fnew
      real atol 

      eps = 1.0e-14
      atol = 1.0e-14 
      newton = 0.0 ! assigned if the solution does not converge 
      x = xi
      fx = f(x,flag,up,yp,rho,mu)
      do i = 1,max(1,maxiter)
c        fx=f(x,flag,up,yp,rho,mu)
        fx1=f(x-eps,flag,up,yp,rho,mu)
        fx2=f(x+eps,flag,up,yp,rho,mu)
        fpr=(fx2-fx1)/(2*eps) ! calculate numerical derivative
c        fpr=fprime(x,flag,up,yp,rho,mu)!calculate analytical derivative
        xnew=x-fx/fpr
        fnew=f(xnew,flag,up,yp,rho,mu)
        if(abs((xnew-x)/xnew).le.rtol .AND. abs(fnew).le.atol) then
c        if(abs((xnew-x)/xnew).le.rtol) then
c        if(abs(fnew).le.atol) then
          newton=xnew
          exit
        endif
        x=xnew
        fx=fnew
      enddo
      
c      write(6,*) 'i, newton, xnew, f = ', i, newton, xnew,
c     $ f(newton,flag,up,yp,rho,mu)      

      return
      end
c---------------------------------------------------------------------
c     SECANT SOLVER 
      real function secant(flag,up,yp,rho,mu,xi1,xi2,rtol,maxiter)
      implicit none
      integer flag,maxiter,i
      real up,yp,rho,mu,xi1,xi2,rtol,x,fx,xprev,fxprev,xnew,f

      secant = 0.0  ! assigned if the solution does not converge
      x = xi2
      xprev = xi1
      fxprev=f(xprev,flag,up,yp,rho,mu)
      do i = 1,max(1,maxiter)
        fx=f(x,flag,up,yp,rho,mu)
        xnew=x-fx*(xprev-x)/(fxprev-fx)
        if(abs((xnew-x)/xnew).le.rtol) then
          secant=xnew
          exit
        endif
        fxprev=fx
        xprev=x
        x=xnew
      enddo

c      write(6,*) 'i, secant, f = ', i, secant, 
c     $ f(secant,flag,up,yp,rho,mu)

      return
      end
c---------------------------------------------------------------------
c     BISECTION SOLVER (not tested)
c      implicit none
c      real function bisection(flag,up,yp,rho,mu,a,b,atol,maxiter)
c      integer flag,maxiter,i
c      real up,yp,rho,mu,a,b,c,atol,fa,fc,f
c
c      bisection = 0.0
c      do i = 1,max(1,maxiter)
c        c=(a+b)/2
c        fc=f(c,flag,up,yp,rho,mu)
c        fa=f(a,flag,up,yp,rho,mu)
c        if((b-a)/2.le.atol .OR. fc.eq.0) then
c          bisection=c
c          exit
c        endif
c      if(fc/abs(fc) .eq. fa/abs(fa)) then
c        a=c
c      else b=c
c      endif 
c      enddo

c      write(6,*) 'i, bisection, f = ', i, bisection, 
c     $ f(bisection,flag,up,yp,rho,mu)

c      return
c      end
c-------------------------------------------------------------------
c-----------------------------------------------------------------------
      subroutine interp_v(uvw,xyz,n)
c
c     evaluate velocity for list of points xyz
c
      include 'SIZE'
      include 'TOTAL'

      real uvw(ldim,n),xyz(ldim,n)

      real    rwk(LPTS,ldim+1) ! r, s, t, dist2
      integer iwk(LPTS,3)      ! code, proc, el
      save    rwk, iwk

      integer intp_h
      save    intp_h

      common /rwk_intp/
     $       fwrk(lx1*ly1*lz1*lelt,ldim),
     $       fpts(ldim*LPTS),
     $       pts(ldim*LPTS)

      integer icalld,e
      save    icalld
      data    icalld /0/

      nxyz  = nx1*ny1*nz1
      ntot  = nxyz*nelt

      if (n.gt.LPTS) call exitti ('n > LPTS in interp_v!$',n)

      if (nelgt.ne.nelgv) call exitti
     $   ('nelgt.ne.nelgv not yet supported in interp_v!$',nelgv)

      do i=1,n                          ! ? not moving -> save?
         pts(i)     = xyz(1,i)
         pts(i + n) = xyz(2,i)
         if (if3d) pts(i + n*2) = xyz(3,i)
      enddo

      if (icalld.eq.0) then
        icalld = 1
        call interp_setup(intp_h,0.0,0,nelt)
      endif

      ! pack working array
      call opcopy(fwrk(1,1),fwrk(1,2),fwrk(1,3),vx,vy,vz)

      ! interpolate
      call interp_nfld(fpts,fwrk,ndim,pts(1),pts(1+n),pts(2*n+1),
     $                 n,iwk,rwk,LPTS,.true.,intp_h)

      do i=1,n
         uvw(1,i) = fpts(i)
         uvw(2,i) = fpts(i + n)
         if(if3d) uvw(3,i) = fpts(i + n*2)
      enddo

      return
      end

